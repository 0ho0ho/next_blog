<?xml version="1.0" encoding="UTF-8"?>
<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
<url>
<loc>class URL {
  constructor(input, base = undefined) {
    // toUSVString is not needed.
    input = `${input}`;
    this[context] = new URLContext();
    this.#onParseComplete = FunctionPrototypeBind(this.#onParseComplete, this);

    if (base !== undefined) {
      base = `${base}`;
    }

    const isValid = parse(input,
                          base,
                          this.#onParseComplete);

    if (!isValid) {
      throw new ERR_INVALID_URL(input);
    }
  }

  [inspect.custom](depth, opts) {
    if (this == null ||
        ObjectGetPrototypeOf(this[context]) !== URLContext.prototype) {
      throw new ERR_INVALID_THIS('URL');
    }

    if (typeof depth === 'number' && depth < 0)
      return this;

    const constructor = getConstructorOf(this) || URL;
    const obj = ObjectCreate({ constructor });

    obj.href = this.href;
    obj.origin = this.origin;
    obj.protocol = this.protocol;
    obj.username = this.username;
    obj.password = this.password;
    obj.host = this.host;
    obj.hostname = this.hostname;
    obj.port = this.port;
    obj.pathname = this.pathname;
    obj.search = this.search;
    obj.searchParams = this.searchParams;
    obj.hash = this.hash;

    if (opts.showHidden) {
      obj[context] = this[context];
    }

    return `${constructor.name} ${inspect(obj, opts)}`;
  }

  #onParseComplete = (href, origin, protocol, hostname, pathname,
                      search, username, password, port, hash) => {
    const ctx = this[context];
    ctx.href = href;
    ctx.origin = origin;
    ctx.protocol = protocol;
    ctx.hostname = hostname;
    ctx.pathname = pathname;
    ctx.search = search;
    ctx.username = username;
    ctx.password = password;
    ctx.port = port;
    ctx.hash = hash;
    if (!this[searchParams]) { // Invoked from URL constructor
      this[searchParams] = new URLSearchParams();
      this[searchParams][context] = this;
    }
    initSearchParams(this[searchParams], ctx.search);
  };

  toString() {
    if (!isURLThis(this))
      throw new ERR_INVALID_THIS('URL');
    return this[context].href;
  }

  get href() {
    if (!isURLThis(this))
      throw new ERR_INVALID_THIS('URL');
    return this[context].href;
  }

  set href(value) {
    if (!isURLThis(this))
      throw new ERR_INVALID_THIS('URL');
    const valid = updateUrl(this[context].href, updateActions.kHref, `${value}`, this.#onParseComplete);
    if (!valid) { throw ERR_INVALID_URL(`${value}`); }
  }

  // readonly
  get origin() {
    if (!isURLThis(this))
      throw new ERR_INVALID_THIS('URL');
    return this[context].origin;
  }

  get protocol() {
    if (!isURLThis(this))
      throw new ERR_INVALID_THIS('URL');
    return this[context].protocol;
  }

  set protocol(value) {
    if (!isURLThis(this))
      throw new ERR_INVALID_THIS('URL');
    updateUrl(this[context].href, updateActions.kProtocol, `${value}`, this.#onParseComplete);
  }

  get username() {
    if (!isURLThis(this))
      throw new ERR_INVALID_THIS('URL');
    return this[context].username;
  }

  set username(value) {
    if (!isURLThis(this))
      throw new ERR_INVALID_THIS('URL');
    updateUrl(this[context].href, updateActions.kUsername, `${value}`, this.#onParseComplete);
  }

  get password() {
    if (!isURLThis(this))
      throw new ERR_INVALID_THIS('URL');
    return this[context].password;
  }

  set password(value) {
    if (!isURLThis(this))
      throw new ERR_INVALID_THIS('URL');
    updateUrl(this[context].href, updateActions.kPassword, `${value}`, this.#onParseComplete);
  }

  get host() {
    if (!isURLThis(this))
      throw new ERR_INVALID_THIS('URL');
    const port = this[context].port;
    const suffix = port.length > 0 ? `:${port}` : '';
    return this[context].hostname + suffix;
  }

  set host(value) {
    if (!isURLThis(this))
      throw new ERR_INVALID_THIS('URL');
    updateUrl(this[context].href, updateActions.kHost, `${value}`, this.#onParseComplete);
  }

  get hostname() {
    if (!isURLThis(this))
      throw new ERR_INVALID_THIS('URL');
    return this[context].hostname;
  }

  set hostname(value) {
    if (!isURLThis(this))
      throw new ERR_INVALID_THIS('URL');
    updateUrl(this[context].href, updateActions.kHostname, `${value}`, this.#onParseComplete);
  }

  get port() {
    if (!isURLThis(this))
      throw new ERR_INVALID_THIS('URL');
    return this[context].port;
  }

  set port(value) {
    if (!isURLThis(this))
      throw new ERR_INVALID_THIS('URL');
    updateUrl(this[context].href, updateActions.kPort, `${value}`, this.#onParseComplete);
  }

  get pathname() {
    if (!isURLThis(this))
      throw new ERR_INVALID_THIS('URL');
    return this[context].pathname;
  }

  set pathname(value) {
    if (!isURLThis(this))
      throw new ERR_INVALID_THIS('URL');
    updateUrl(this[context].href, updateActions.kPathname, `${value}`, this.#onParseComplete);
  }

  get search() {
    if (!isURLThis(this))
      throw new ERR_INVALID_THIS('URL');
    return this[context].search;
  }

  set search(search) {
    if (!isURLThis(this))
      throw new ERR_INVALID_THIS('URL');
    search = toUSVString(search);
    updateUrl(this[context].href, updateActions.kSearch, search, this.#onParseComplete);
    initSearchParams(this[searchParams], this[context].search);
  }

  // readonly
  get searchParams() {
    if (!isURLThis(this))
      throw new ERR_INVALID_THIS('URL');
    return this[searchParams];
  }

  get hash() {
    if (!isURLThis(this))
      throw new ERR_INVALID_THIS('URL');
    return this[context].hash;
  }

  set hash(value) {
    if (!isURLThis(this))
      throw new ERR_INVALID_THIS('URL');
    updateUrl(this[context].href, updateActions.kHash, `${value}`, this.#onParseComplete);
  }

  toJSON() {
    if (!isURLThis(this))
      throw new ERR_INVALID_THIS('URL');
    return this[context].href;
  }

  static createObjectURL(obj) {
    const cryptoRandom = lazyCryptoRandom();
    if (cryptoRandom === undefined)
      throw new ERR_NO_CRYPTO();

    const blob = lazyBlob();
    if (!blob.isBlob(obj))
      throw new ERR_INVALID_ARG_TYPE('obj', 'Blob', obj);

    const id = cryptoRandom.randomUUID();

    storeDataObject(id, obj[blob.kHandle], obj.size, obj.type);

    return `blob:nodedata:${id}`;
  }

  static revokeObjectURL(url) {
    url = `${url}`;
    try {
      // TODO(@anonrig): Remove this try/catch by calling `parse` directly.
      const parsed = new URL(url);
      const split = StringPrototypeSplit(parsed.pathname, ':');
      if (split.length === 2)
        revokeDataObject(split[1]);
    } catch {
      // If there's an error, it's ignored.
    }
  }
}/</loc>
<lastmod>2023-10-03T09:11:55.752Z</lastmod>
</url>
<url>
<loc>https://oungo.github.io/posts/220523_babel</loc>
<lastmod>2022-05-23</lastmod>
</url>
<url>
<loc>https://oungo.github.io/posts/220301_nextjs</loc>
<lastmod>2022-03-01</lastmod>
</url>
<url>
<loc>https://oungo.github.io/posts/210101_2020_summary</loc>
<lastmod>2021-01-03T05:35:07.322Z</lastmod>
</url>
</urlset>
