<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/_next/static/css/7331c1540611ce60.css" data-precedence="next"/><link rel="preload" href="/_next/static/chunks/webpack-5b1cd59632d4e6ef.js" as="script" fetchPriority="low"/><script src="/_next/static/chunks/fd9d1056-e43e6bee82f6984c.js" async=""></script><script src="/_next/static/chunks/864-a0cafa32186c998e.js" async=""></script><script src="/_next/static/chunks/main-app-aa0a94018ed42b6f.js" async=""></script><link rel="preload" href="https://www.googletagmanager.com/gtag/js?id=G-RF88KSS1WC" as="script"/><title>Next.js SSG, SSR, ISR - oungo</title><meta name="description" content="코로나 격리기간 중 할게 없어서 간만에 Next.js 문서 정독을 했다. 모든 기능을 설명하에는 글이 너무 길어질것 같고, Next.js에서 가장 핵심이라고 할 수 있는 SSG, SSR, ISR에 대해 정리해보려고 한다."/><link rel="canonical" href="https://oungo.github.io/"/><meta property="og:title" content="Next.js SSG, SSR, ISR"/><meta property="og:description" content="코로나 격리기간 중 할게 없어서 간만에 Next.js 문서 정독을 했다. 모든 기능을 설명하에는 글이 너무 길어질것 같고, Next.js에서 가장 핵심이라고 할 수 있는 SSG, SSR, ISR에 대해 정리해보려고 한다."/><meta property="og:url" content="https://oungo.github.io/posts/220301_nextjs"/><meta name="twitter:card" content="summary"/><meta name="twitter:title" content="Next.js SSG, SSR, ISR"/><meta name="twitter:description" content="코로나 격리기간 중 할게 없어서 간만에 Next.js 문서 정독을 했다. 모든 기능을 설명하에는 글이 너무 길어질것 같고, Next.js에서 가장 핵심이라고 할 수 있는 SSG, SSR, ISR에 대해 정리해보려고 한다."/><link rel="icon" href="/favicon.ico" type="image/x-icon" sizes="16x16"/><script src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js" noModule=""></script></head><body><header class="py-10 text-3xl text-center"><a href="/">oungo</a></header><main class="max-w-3xl px-5 m-auto"><article><h1 class="text-3xl font-extrabold">Next.js SSG, SSR, ISR</h1><time class="text-gray-400" dateTime="2022-03-01">2022 March 1</time><div class="mt-5 prose"><p>코로나 격리 기간에 할 게 없어서 간만에 Next.js 문서 정독을 했다. 모든 기능을 설명하기에는 글이 너무 길어질 것 같고, Next.js에서 가장 핵심이라고 할 수 있는 SSG, SSR, ISR에 대해 정리해보려고 한다.</p>
<h2>Next.js</h2>
<p>Next.js는 리액트 프레임워크다. 서버 사이드 렌더링이나 다이나믹 라우팅 등 리액트 어플리케이션을 개발할 때 필요한 기능들을 쉽게 사용할 수 있도록 도와주는 역할을 한다. 이는 Next.js에서 요구하는 조건에 맞춰서 코드를 작성하기만 하면 된다. 서버 사이드 렌더링과 클라이언트 사이드 렌더링의 차이는 아래 이미지로 확인할 수 있다.</p>
<p><img src="/assets/blog/nextjs/ssr.png" alt="ssr">
<img src="/assets/blog/nextjs/csr.png" alt="csr">
출처 <a href="https://medium.com/walmartglobaltech/the-benefits-of-server-side-rendering-over-client-side-rendering-5d07ff2cefe8">The Benefits of Server Side Rendering Over Client Side Rendering</a></p>
<h2>Pre-rendering</h2>
<p>Next.js에서 가장 중요한 컨셉 중 하나가 Pre-rendering이다. 각 페이지의 HTML을 미리 만들어 놓는다는 뜻이다. pre-rendeing이 발생하는지는 간단한 테스트를 통해 확인해 볼 수 있다.</p>
<ol>
<li>
<p>먼저 <code>npx create-next-app nextjs-example</code> 명령어를 통해 Next.js 기본 프로젝트를 만들어주고, 실행한다.</p>
</li>
<li>
<p>크롬 개발자 모드를 켜고, command + shift + p를 눌러서 disable javascript를 누르고 새로고침을 한다. 그러면 자바스크립트를 실행하지 않아도 미리 만들어둔 Html을 보여줌으로써 어플리케이션의 ui를 확인할 수 있습니다.</p>
</li>
<li>
<p>똑같은 방식으로 <code>create-react-app</code> 프로젝트를 만들어서 비교해 보면 둘의 차이를 알 수 있다.</p>
</li>
</ol>
<h2>Static Generation, Server-side Rendering</h2>
<p>Pre-rendering은 크게 두 가지 방식으로 나뉠 수 있는데 Static Generation과 Server-side Rendering이다. 공식 문서에 아래와 같이 설명하고 있다.</p>
<blockquote>
<p><code>Static Generation</code> is the pre-rendering method that generates the HTML at <code>build time</code>. The pre-rendered HTML is then reused on each request.</p>
</blockquote>
<blockquote>
<p><code>Server-side Rendering</code> is the pre-rendering method that generates the HTML on <code>each request</code>.</p>
</blockquote>
<p>다시 설명하면 Static Generation은 빌드 할 때 HTML을 생성해놓고, 요청이 들어오면 빌드 할 때 만들어둔 HTML을 보여준다. Server-side Rendering은 매 요청 시 HTML을 생성해서 보여준다.</p>
<h2>getStaticProps</h2>
<p>Next.js에서는 Static Generation 사용을 권장한다. 사용자의 요청과는 관계없이 보여줄 수 있는 페이지라면 Static Generation을 사용하면 된다. Static Generation 사용 방식은 간단하다.</p>
<p>아래와 같이 getStaticProps을 작성하면 Next.js는 빌드 할 때 getStaticProps로부터 리턴된 props를 사용하여 해당 페이지를 pre-render 한다.</p>
<pre><code class="language-typescript">export default function Home(props) { ... }

export async function getStaticProps() {
  const data = { name: 'haha' };

  return {
    props: {
      data
    }
  }
}
</code></pre>
<p>getStaticProps는 서버사이드에서만 실행된다. javascript bundle에도 포함되지 않는다. 따라서 브라우저를 통하지 않고, getStaticProps 내에서 바로 쿼리를 호출하여 데이터를 가져올 수 있다.</p>
<h2>getServerSideProps</h2>
<p>Server-side Rendering의 사용법도 비슷하다. getStaticProps 대신 getServerSideProps를 사용하면 된다.</p>
<p>아래와 같이 getServerSideProps를 작성하면 매 요청 시마다 getServerSideProps에서 리턴된 데이터를 가지고 해당 페이지를 pre-render 한다. getServerSideProps 또한 서버사이드에서만 실행된다.</p>
<p>getServerSideProps에서 받고 있는 context에는 다양한 데이터가 담겨있는데 자세한 건 <a href="https://nextjs.org/docs/api-reference/data-fetching/get-server-side-props">API 문서</a>를 살펴보자.</p>
<pre><code class="language-typescript">export async function getServerSideProps(context) {
  const data = { name: 'haha' };

  return {
    props: {
      data,
    },
  };
}
</code></pre>
<h2>Incremental Static Regeneration(ISR)</h2>
<p>Static Generation은 빌드 할 때 HTML을 만들어 두기 때문에 보통 정적인 데이터를 보여주고자 할 때 사용된다. 하지만 Incremental Static Regeneration을 사용하면 빌드 후에도 변경된 데이터를 가져올 수 있다. getStaticProps에 revalidate prop을 추가하면 된다.</p>
<pre><code class="language-tsx">import styles from '../styles/Home.module.css';
import axios from 'axios';

export default function Home({ data }) {
  return (
    &#x3C;div className={styles.container}>
      &#x3C;h1>{data}&#x3C;/h1>
    &#x3C;/div>
  );
}

export async function getStaticProps() {
  // 현재 시간을 가져오는 API
  const res = await axios.get('https://worldtimeapi.org/api/ip');
  return {
    props: {
      data: res.data.datetime,
    },
  };
}
</code></pre>
<p>위와 같은 코드를 작성하고 빌드 후 실행시키면 시간을 화면에 보여주는데 페이지를 새로고침해도 처음 빌드할 때 getStaticProps를 통해 데이터를 가져왔기 때문에 시간은 바뀌지 않는다.</p>
<p>이번엔 revalidate prop을 추가해 보자.</p>
<pre><code class="language-typescript">export async function getStaticProps() {
  const res = await axios.get('https://worldtimeapi.org/api/ip');

  return {
    props: {
      data: res.data.datetime,
    },
    revalidate: 60,
  };
}
</code></pre>
<p><code>revalidate</code>를 추가하면 Next.js는 요청이 들어왔을 때, 최대 10초에 한 번 페이지 regeneration을 수행할 것이다.</p>
<p>revalidate를 추가했을 때 동작 방식은 다음과 같다.</p>
<ol>
<li>
<p>페이지 요청이 들어오면 캐시 된 페이지를 보여준다.</p>
</li>
<li>
<p>최초 페이지 요청 후 60초 내로 들어오는 요청들도 캐시 된 페이지를 보여준다.</p>
</li>
<li>
<p>10 초 후 요청이 들어왔을 때도 저장된 페이지를 보여주고, Next.js는 백그라운드에서 페이지 regeneration을 수행한다.</p>
</li>
<li>
<p>페이지 regeneration이 성공적으로 됐을 경우 이전의 캐시를 없애고 새로운 페이지를 보여준다.</p>
</li>
</ol>
<p><img src="/assets/blog/nextjs/isr.png" alt="ISR">
출처 <a href="https://vercel.com/docs/concepts/next.js/incremental-static-regeneration">Incremental Static Regeneration</a></p>
<p>이처럼 getStaticProps에 revalidate를 사용하면 데이터가 변경되더라도 계속해서 새로운 데이터를 보여줄 수 있다.</p>
<h2>On-Demand Revalidation (Beta)</h2>
<p>ISR를 통해 SSG에서 정적인 데이터만 보여준다는 단점을 보완할 수 있다. 하지만 <code>revalidate</code>를 설정하면 특정 시간 내에는 무조건 동일한 데이터를 가진 페이지를 볼 수밖에 없다. 그 사이에 데이터가 변경된다고 하더라도 새로운 데이터를 확인할 수 있는 유일한 방법은 revalidate에 설정한 시간이 지난 후 누군가 페이지를 요청을 보내는 것뿐이다.</p>
<p>하지만 Next.js <code>v12.1.0</code> 부터는 On-Demand Revalidation을 지원한다. 원하는 시점에 캐시 된 페이지를 지우고 페이지 regeneration이 가능하다.</p>
<p>사용 방법은 기존에 있던 revalidate를 삭제하고, unstable_revalidate를 사용하면 된다.
먼저 pages/api/revalidate.js 파일에 아래와 같은 코드를 넣어준다.</p>
<p>unstable_revalidate에는 revalidate할 페이지를 넣어준다. 여기서는 인덱스 페이지에 적용할 것이기 때문에 '/'를 넣어줬다</p>
<pre><code class="language-typescript">// pages/api/revalidate.js

export default async function handler(req, res) {
  // Check for secret to confirm this is a valid request
  if (req.query.secret !== process.env.MY_SECRET_TOKEN) {
    return res.status(401).json({ message: 'Invalid token' });
  }

  try {
    await res.unstable_revalidate('/');
    return res.json({ revalidated: true });
  } catch (err) {
    // If there was an error, Next.js will continue
    // to show the last successfully generated page
    return res.status(500).send('Error revalidating');
  }
}
</code></pre>
<p>그리고 Home 컴포넌트에서는 revalidate를 수행할 버튼을 만들고 위에서 만든 걸 호출하면 된다.</p>
<pre><code class="language-tsx">import styles from '../styles/Home.module.css';
import axios from 'axios';

export default function Home({ data }) {
  function revalidate() {
    fetch('/api/revalidate');
  }

  return (
    &#x3C;div className={styles.container}>
      &#x3C;h1>{data}&#x3C;/h1>
      &#x3C;button onClick={() => revalidate()}>Revalidate&#x3C;/button>
    &#x3C;/div>
  );
}

export async function getStaticProps() {
  const res = await axios.get('https://worldtimeapi.org/api/ip');
  return {
    props: {
      data: res.data.datetime,
    },
    // revalidate: 5
  };
}
</code></pre>
<p>그럼 아래와 같이 동작한다.
버튼을 누르지 않고 새로고침을 하면 계속 동일한 시간이 나온다.
revalidate 버튼을 누르고, 다시 새로 고침을 누르면 변경된 시간을 확인할 수 있다.</p>
<p><img src="/assets/blog/nextjs/on-demand.gif" alt="ISR"></p>
<h2>마무리</h2>
<p>Next.js에서 가장 핵심이라고 할 수 있는 SSG, SSR, ISR 그리고 가장 최근에 나온 On-Demand Revalidation (Beta)까지 알아보았다. 참고로 전부 page 내에서만 사용이 가능하고, 페이지별로 다르게 적용할 수 있다.</p>
<p>예전에 처음 Next.js로 프로젝트를 시작했을 때는 getInitialProps밖에 없었던 걸로 기억하는데 그동안 많이 바뀐 것 같다. Next.js를 사용해 보지 않았다면 한번쯤 사용해 보는 것을 추천한다. 사용법도 간단하고 문서도 굉장히 잘 되어있기 때문에 초보자가 접근하기에도 무리가 없을 거라고 생각한다.</p>
</div></article></main><footer class="py-12 text-lg text-center text-teal-600"></footer><script src="/_next/static/chunks/webpack-5b1cd59632d4e6ef.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/css/7331c1540611ce60.css\",\"style\"]\n0:\"$L2\"\n"])</script><script>self.__next_f.push([1,"3:I{\"id\":6054,\"chunks\":[\"272:static/chunks/webpack-5b1cd59632d4e6ef.js\",\"971:static/chunks/fd9d1056-e43e6bee82f6984c.js\",\"864:static/chunks/864-a0cafa32186c998e.js\"],\"name\":\"\",\"async\":false}\n5:I{\"id\":1729,\"chunks\":[\"272:static/chunks/webpack-5b1cd59632d4e6ef.js\",\"971:static/chunks/fd9d1056-e43e6bee82f6984c.js\",\"864:static/chunks/864-a0cafa32186c998e.js\"],\"name\":\"\",\"async\":false}\n6:I{\"id\":4724,\"chunks\":[\"724:static/chunks/724-6cb69ef6fafa77fc.js\",\"931:static/chunks/app/page-a049813ca3edbfcc.js\"],\"name\":\"\",\"a"])</script><script>self.__next_f.push([1,"sync\":false}\n7:I{\"id\":1443,\"chunks\":[\"272:static/chunks/webpack-5b1cd59632d4e6ef.js\",\"971:static/chunks/fd9d1056-e43e6bee82f6984c.js\",\"864:static/chunks/864-a0cafa32186c998e.js\"],\"name\":\"\",\"async\":false}\n8:I{\"id\":8639,\"chunks\":[\"272:static/chunks/webpack-5b1cd59632d4e6ef.js\",\"971:static/chunks/fd9d1056-e43e6bee82f6984c.js\",\"864:static/chunks/864-a0cafa32186c998e.js\"],\"name\":\"\",\"async\":false}\nb:I{\"id\":4244,\"chunks\":[\"724:static/chunks/724-6cb69ef6fafa77fc.js\",\"185:static/chunks/app/layout-97468fda4d0838e5.js"])</script><script>self.__next_f.push([1,"\"],\"name\":\"\",\"async\":false}\n"])</script><script>self.__next_f.push([1,"2:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/7331c1540611ce60.css\",\"precedence\":\"next\"}]],[\"$\",\"$L3\",null,{\"buildId\":\"XnBuCzyQnFraFTaGlyfGa\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/posts/220301_nextjs\",\"initialTree\":[\"\",{\"children\":[\"posts\",{\"children\":[[\"slug\",\"220301_nextjs\",\"d\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":\\\"220301_nextjs\\\"}\",{}]}]}]},\"$undefined\",\"$undefined\",true],\"initialHead\":[false,\"$L4\"],\"globalErrorComponent\":\"$5\",\"children\":[null,[\"$\",\"html\",null,{\"lang\":\"en\",\"children\":[\"$\",\"body\",null,{\"children\":[[[\"$\",\"header\",null,{\"className\":\"py-10 text-3xl text-center\",\"children\":[\"$\",\"$L6\",null,{\"href\":\"/\",\"children\":\"oungo\"}]}],[\"$\",\"main\",null,{\"className\":\"max-w-3xl px-5 m-auto\",\"children\":[\"$\",\"$L7\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"notFound\":[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":\"404\"}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],\"notFoundStyles\":[],\"childProp\":{\"current\":[\"$\",\"$L7\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"posts\",\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"childProp\":{\"current\":[\"$\",\"$L7\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"posts\",\"children\",[\"slug\",\"220301_nextjs\",\"d\"],\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"childProp\":{\"current\":[\"$L9\",\"$La\",null],\"segment\":\"__PAGE__?{\\\"slug\\\":\\\"220301_nextjs\\\"}\"},\"styles\":[]}],\"segment\":[\"slug\",\"220301_nextjs\",\"d\"]},\"styles\":[]}],\"segment\":\"posts\"},\"styles\":[]}]}],[\"$\",\"footer\",null,{\"className\":\"py-12 text-lg text-center text-teal-600\"}]],[[\"$\",\"$Lb\",null,{\"strategy\":\"afterInteractive\",\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-RF88KSS1WC\"}],[\"$\",\"$Lb\",null,{\"id\":\"gtag-init\",\"strategy\":\"afterInteractive\",\"dangerouslySetInnerHTML\":{\"__html\":\"\\n                  window.dataLayer = window.dataLayer || [];\\n                  function gtag(){dataLayer.push(arguments);}\\n                  gtag('js', new Date());\\n                  gtag('config', 'G-RF88KSS1WC', {\\n                    page_path: window.location.pathname,\\n                  });\\n                \"}}]]]}]}],null]}]]\n"])</script><script>self.__next_f.push([1,"c:I{\"id\":5992,\"chunks\":[\"719:static/chunks/719-59bc62928b316beb.js\",\"333:static/chunks/app/posts/[slug]/page-69e18a1ca0bfec63.js\"],\"name\":\"\",\"async\":false}\nd:T285f,"])</script><script>self.__next_f.push([1,"\u003cp\u003e코로나 격리 기간에 할 게 없어서 간만에 Next.js 문서 정독을 했다. 모든 기능을 설명하기에는 글이 너무 길어질 것 같고, Next.js에서 가장 핵심이라고 할 수 있는 SSG, SSR, ISR에 대해 정리해보려고 한다.\u003c/p\u003e\n\u003ch2\u003eNext.js\u003c/h2\u003e\n\u003cp\u003eNext.js는 리액트 프레임워크다. 서버 사이드 렌더링이나 다이나믹 라우팅 등 리액트 어플리케이션을 개발할 때 필요한 기능들을 쉽게 사용할 수 있도록 도와주는 역할을 한다. 이는 Next.js에서 요구하는 조건에 맞춰서 코드를 작성하기만 하면 된다. 서버 사이드 렌더링과 클라이언트 사이드 렌더링의 차이는 아래 이미지로 확인할 수 있다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/blog/nextjs/ssr.png\" alt=\"ssr\"\u003e\n\u003cimg src=\"/assets/blog/nextjs/csr.png\" alt=\"csr\"\u003e\n출처 \u003ca href=\"https://medium.com/walmartglobaltech/the-benefits-of-server-side-rendering-over-client-side-rendering-5d07ff2cefe8\"\u003eThe Benefits of Server Side Rendering Over Client Side Rendering\u003c/a\u003e\u003c/p\u003e\n\u003ch2\u003ePre-rendering\u003c/h2\u003e\n\u003cp\u003eNext.js에서 가장 중요한 컨셉 중 하나가 Pre-rendering이다. 각 페이지의 HTML을 미리 만들어 놓는다는 뜻이다. pre-rendeing이 발생하는지는 간단한 테스트를 통해 확인해 볼 수 있다.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e먼저 \u003ccode\u003enpx create-next-app nextjs-example\u003c/code\u003e 명령어를 통해 Next.js 기본 프로젝트를 만들어주고, 실행한다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e크롬 개발자 모드를 켜고, command + shift + p를 눌러서 disable javascript를 누르고 새로고침을 한다. 그러면 자바스크립트를 실행하지 않아도 미리 만들어둔 Html을 보여줌으로써 어플리케이션의 ui를 확인할 수 있습니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e똑같은 방식으로 \u003ccode\u003ecreate-react-app\u003c/code\u003e 프로젝트를 만들어서 비교해 보면 둘의 차이를 알 수 있다.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2\u003eStatic Generation, Server-side Rendering\u003c/h2\u003e\n\u003cp\u003ePre-rendering은 크게 두 가지 방식으로 나뉠 수 있는데 Static Generation과 Server-side Rendering이다. 공식 문서에 아래와 같이 설명하고 있다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003ccode\u003eStatic Generation\u003c/code\u003e is the pre-rendering method that generates the HTML at \u003ccode\u003ebuild time\u003c/code\u003e. The pre-rendered HTML is then reused on each request.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003ccode\u003eServer-side Rendering\u003c/code\u003e is the pre-rendering method that generates the HTML on \u003ccode\u003eeach request\u003c/code\u003e.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e다시 설명하면 Static Generation은 빌드 할 때 HTML을 생성해놓고, 요청이 들어오면 빌드 할 때 만들어둔 HTML을 보여준다. Server-side Rendering은 매 요청 시 HTML을 생성해서 보여준다.\u003c/p\u003e\n\u003ch2\u003egetStaticProps\u003c/h2\u003e\n\u003cp\u003eNext.js에서는 Static Generation 사용을 권장한다. 사용자의 요청과는 관계없이 보여줄 수 있는 페이지라면 Static Generation을 사용하면 된다. Static Generation 사용 방식은 간단하다.\u003c/p\u003e\n\u003cp\u003e아래와 같이 getStaticProps을 작성하면 Next.js는 빌드 할 때 getStaticProps로부터 리턴된 props를 사용하여 해당 페이지를 pre-render 한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-typescript\"\u003eexport default function Home(props) { ... }\n\nexport async function getStaticProps() {\n  const data = { name: 'haha' };\n\n  return {\n    props: {\n      data\n    }\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003egetStaticProps는 서버사이드에서만 실행된다. javascript bundle에도 포함되지 않는다. 따라서 브라우저를 통하지 않고, getStaticProps 내에서 바로 쿼리를 호출하여 데이터를 가져올 수 있다.\u003c/p\u003e\n\u003ch2\u003egetServerSideProps\u003c/h2\u003e\n\u003cp\u003eServer-side Rendering의 사용법도 비슷하다. getStaticProps 대신 getServerSideProps를 사용하면 된다.\u003c/p\u003e\n\u003cp\u003e아래와 같이 getServerSideProps를 작성하면 매 요청 시마다 getServerSideProps에서 리턴된 데이터를 가지고 해당 페이지를 pre-render 한다. getServerSideProps 또한 서버사이드에서만 실행된다.\u003c/p\u003e\n\u003cp\u003egetServerSideProps에서 받고 있는 context에는 다양한 데이터가 담겨있는데 자세한 건 \u003ca href=\"https://nextjs.org/docs/api-reference/data-fetching/get-server-side-props\"\u003eAPI 문서\u003c/a\u003e를 살펴보자.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-typescript\"\u003eexport async function getServerSideProps(context) {\n  const data = { name: 'haha' };\n\n  return {\n    props: {\n      data,\n    },\n  };\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eIncremental Static Regeneration(ISR)\u003c/h2\u003e\n\u003cp\u003eStatic Generation은 빌드 할 때 HTML을 만들어 두기 때문에 보통 정적인 데이터를 보여주고자 할 때 사용된다. 하지만 Incremental Static Regeneration을 사용하면 빌드 후에도 변경된 데이터를 가져올 수 있다. getStaticProps에 revalidate prop을 추가하면 된다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-tsx\"\u003eimport styles from '../styles/Home.module.css';\nimport axios from 'axios';\n\nexport default function Home({ data }) {\n  return (\n    \u0026#x3C;div className={styles.container}\u003e\n      \u0026#x3C;h1\u003e{data}\u0026#x3C;/h1\u003e\n    \u0026#x3C;/div\u003e\n  );\n}\n\nexport async function getStaticProps() {\n  // 현재 시간을 가져오는 API\n  const res = await axios.get('https://worldtimeapi.org/api/ip');\n  return {\n    props: {\n      data: res.data.datetime,\n    },\n  };\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위와 같은 코드를 작성하고 빌드 후 실행시키면 시간을 화면에 보여주는데 페이지를 새로고침해도 처음 빌드할 때 getStaticProps를 통해 데이터를 가져왔기 때문에 시간은 바뀌지 않는다.\u003c/p\u003e\n\u003cp\u003e이번엔 revalidate prop을 추가해 보자.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-typescript\"\u003eexport async function getStaticProps() {\n  const res = await axios.get('https://worldtimeapi.org/api/ip');\n\n  return {\n    props: {\n      data: res.data.datetime,\n    },\n    revalidate: 60,\n  };\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003erevalidate\u003c/code\u003e를 추가하면 Next.js는 요청이 들어왔을 때, 최대 10초에 한 번 페이지 regeneration을 수행할 것이다.\u003c/p\u003e\n\u003cp\u003erevalidate를 추가했을 때 동작 방식은 다음과 같다.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e페이지 요청이 들어오면 캐시 된 페이지를 보여준다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e최초 페이지 요청 후 60초 내로 들어오는 요청들도 캐시 된 페이지를 보여준다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e10 초 후 요청이 들어왔을 때도 저장된 페이지를 보여주고, Next.js는 백그라운드에서 페이지 regeneration을 수행한다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e페이지 regeneration이 성공적으로 됐을 경우 이전의 캐시를 없애고 새로운 페이지를 보여준다.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cimg src=\"/assets/blog/nextjs/isr.png\" alt=\"ISR\"\u003e\n출처 \u003ca href=\"https://vercel.com/docs/concepts/next.js/incremental-static-regeneration\"\u003eIncremental Static Regeneration\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e이처럼 getStaticProps에 revalidate를 사용하면 데이터가 변경되더라도 계속해서 새로운 데이터를 보여줄 수 있다.\u003c/p\u003e\n\u003ch2\u003eOn-Demand Revalidation (Beta)\u003c/h2\u003e\n\u003cp\u003eISR를 통해 SSG에서 정적인 데이터만 보여준다는 단점을 보완할 수 있다. 하지만 \u003ccode\u003erevalidate\u003c/code\u003e를 설정하면 특정 시간 내에는 무조건 동일한 데이터를 가진 페이지를 볼 수밖에 없다. 그 사이에 데이터가 변경된다고 하더라도 새로운 데이터를 확인할 수 있는 유일한 방법은 revalidate에 설정한 시간이 지난 후 누군가 페이지를 요청을 보내는 것뿐이다.\u003c/p\u003e\n\u003cp\u003e하지만 Next.js \u003ccode\u003ev12.1.0\u003c/code\u003e 부터는 On-Demand Revalidation을 지원한다. 원하는 시점에 캐시 된 페이지를 지우고 페이지 regeneration이 가능하다.\u003c/p\u003e\n\u003cp\u003e사용 방법은 기존에 있던 revalidate를 삭제하고, unstable_revalidate를 사용하면 된다.\n먼저 pages/api/revalidate.js 파일에 아래와 같은 코드를 넣어준다.\u003c/p\u003e\n\u003cp\u003eunstable_revalidate에는 revalidate할 페이지를 넣어준다. 여기서는 인덱스 페이지에 적용할 것이기 때문에 '/'를 넣어줬다\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-typescript\"\u003e// pages/api/revalidate.js\n\nexport default async function handler(req, res) {\n  // Check for secret to confirm this is a valid request\n  if (req.query.secret !== process.env.MY_SECRET_TOKEN) {\n    return res.status(401).json({ message: 'Invalid token' });\n  }\n\n  try {\n    await res.unstable_revalidate('/');\n    return res.json({ revalidated: true });\n  } catch (err) {\n    // If there was an error, Next.js will continue\n    // to show the last successfully generated page\n    return res.status(500).send('Error revalidating');\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그리고 Home 컴포넌트에서는 revalidate를 수행할 버튼을 만들고 위에서 만든 걸 호출하면 된다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-tsx\"\u003eimport styles from '../styles/Home.module.css';\nimport axios from 'axios';\n\nexport default function Home({ data }) {\n  function revalidate() {\n    fetch('/api/revalidate');\n  }\n\n  return (\n    \u0026#x3C;div className={styles.container}\u003e\n      \u0026#x3C;h1\u003e{data}\u0026#x3C;/h1\u003e\n      \u0026#x3C;button onClick={() =\u003e revalidate()}\u003eRevalidate\u0026#x3C;/button\u003e\n    \u0026#x3C;/div\u003e\n  );\n}\n\nexport async function getStaticProps() {\n  const res = await axios.get('https://worldtimeapi.org/api/ip');\n  return {\n    props: {\n      data: res.data.datetime,\n    },\n    // revalidate: 5\n  };\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그럼 아래와 같이 동작한다.\n버튼을 누르지 않고 새로고침을 하면 계속 동일한 시간이 나온다.\nrevalidate 버튼을 누르고, 다시 새로 고침을 누르면 변경된 시간을 확인할 수 있다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/blog/nextjs/on-demand.gif\" alt=\"ISR\"\u003e\u003c/p\u003e\n\u003ch2\u003e마무리\u003c/h2\u003e\n\u003cp\u003eNext.js에서 가장 핵심이라고 할 수 있는 SSG, SSR, ISR 그리고 가장 최근에 나온 On-Demand Revalidation (Beta)까지 알아보았다. 참고로 전부 page 내에서만 사용이 가능하고, 페이지별로 다르게 적용할 수 있다.\u003c/p\u003e\n\u003cp\u003e예전에 처음 Next.js로 프로젝트를 시작했을 때는 getInitialProps밖에 없었던 걸로 기억하는데 그동안 많이 바뀐 것 같다. Next.js를 사용해 보지 않았다면 한번쯤 사용해 보는 것을 추천한다. 사용법도 간단하고 문서도 굉장히 잘 되어있기 때문에 초보자가 접근하기에도 무리가 없을 거라고 생각한다.\u003c/p\u003e\n"])</script><script>self.__next_f.push([1,"a:[\"$\",\"article\",null,{\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-3xl font-extrabold\",\"children\":\"Next.js SSG, SSR, ISR\"}],[\"$\",\"time\",null,{\"className\":\"text-gray-400\",\"dateTime\":\"2022-03-01\",\"children\":\"2022 March 1\"}],[\"$\",\"$Lc\",null,{\"content\":\"$d\"}]]}]\n"])</script><script>self.__next_f.push([1,"4:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"1\",{\"children\":\"Next.js SSG, SSR, ISR - oungo\"}],[\"$\",\"meta\",\"2\",{\"name\":\"description\",\"content\":\"코로나 격리기간 중 할게 없어서 간만에 Next.js 문서 정독을 했다. 모든 기능을 설명하에는 글이 너무 길어질것 같고, Next.js에서 가장 핵심이라고 할 수 있는 SSG, SSR, ISR에 대해 정리해보려고 한다.\"}],[\"$\",\"meta\",\"3\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"link\",\"4\",{\"rel\":\"canonical\",\"href\":\"https://oungo.github.io/\"}],[\"$\",\"meta\",\"5\",{\"property\":\"og:title\",\"content\":\"Next.js SSG, SSR, ISR\"}],[\"$\",\"meta\",\"6\",{\"property\":\"og:description\",\"content\":\"코로나 격리기간 중 할게 없어서 간만에 Next.js 문서 정독을 했다. 모든 기능을 설명하에는 글이 너무 길어질것 같고, Next.js에서 가장 핵심이라고 할 수 있는 SSG, SSR, ISR에 대해 정리해보려고 한다.\"}],[\"$\",\"meta\",\"7\",{\"property\":\"og:url\",\"content\":\"https://oungo.github.io/posts/220301_nextjs\"}],[\"$\",\"meta\",\"8\",{\"name\":\"twitter:card\",\"content\":\"summary\"}],[\"$\",\"meta\",\"9\",{\"name\":\"twitter:title\",\"content\":\"Next.js SSG, SSR, ISR\"}],[\"$\",\"meta\",\"10\",{\"name\":\"twitter:description\",\"content\":\"코로나 격리기간 중 할게 없어서 간만에 Next.js 문서 정독을 했다. 모든 기능을 설명하에는 글이 너무 길어질것 같고, Next.js에서 가장 핵심이라고 할 수 있는 SSG, SSR, ISR에 대해 정리해보려고 한다.\"}],[\"$\",\"link\",\"11\",{\"rel\":\"icon\",\"href\":\"/favicon.ico\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}]]\n"])</script><script>self.__next_f.push([1,"9:null\n"])</script></body></html>