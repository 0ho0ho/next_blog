1:HL["/_next/static/css/9b86d158957fd71b.css","style"]
0:["oXvvnNSukzrbzXv6aXgut",[[["",{"children":["posts",{"children":[["slug","useEffect","d"],{"children":["__PAGE__?{\"slug\":\"useEffect\"}",{}]}]}]},"$undefined","$undefined",true],"$L2",[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/9b86d158957fd71b.css","precedence":"next"}]],"$L3"]]]]
4:HL["/_next/static/css/f68b3b8746d2b056.css","style"]
5:I{"id":404,"chunks":["724:static/chunks/724-09e481ac835dbe53.js","185:static/chunks/app/layout-d50ac3a5ad497e37.js"],"name":"","async":false}
6:I{"id":1443,"chunks":["272:static/chunks/webpack-250c8836cd5e2c94.js","971:static/chunks/fd9d1056-201df9ae58bf336d.js","864:static/chunks/864-0be03c861a542b53.js"],"name":"","async":false}
7:I{"id":8639,"chunks":["272:static/chunks/webpack-250c8836cd5e2c94.js","971:static/chunks/fd9d1056-201df9ae58bf336d.js","864:static/chunks/864-0be03c861a542b53.js"],"name":"","async":false}
a:I{"id":4244,"chunks":["724:static/chunks/724-09e481ac835dbe53.js","185:static/chunks/app/layout-d50ac3a5ad497e37.js"],"name":"","async":false}
2:[null,["$","html",null,{"lang":"ko","children":["$","body",null,{"children":[[["$","$L5",null,{}],["$","main",null,{"className":"max-w-screen-md px-5 py-20 m-auto","children":["$","$L6",null,{"parallelRouterKey":"children","segmentPath":["children"],"loading":"$undefined","loadingStyles":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","template":["$","$L7",null,{}],"templateStyles":"$undefined","notFound":[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":"404"}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]],"notFoundStyles":[],"childProp":{"current":["$","$L6",null,{"parallelRouterKey":"children","segmentPath":["children","posts","children"],"loading":"$undefined","loadingStyles":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","template":["$","$L7",null,{}],"templateStyles":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","childProp":{"current":["$","$L6",null,{"parallelRouterKey":"children","segmentPath":["children","posts","children",["slug","useEffect","d"],"children"],"loading":"$undefined","loadingStyles":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","template":["$","$L7",null,{}],"templateStyles":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","childProp":{"current":["$L8","$L9",null],"segment":"__PAGE__?{\"slug\":\"useEffect\"}"},"styles":[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/f68b3b8746d2b056.css","precedence":"next"}]]}],"segment":["slug","useEffect","d"]},"styles":[]}],"segment":"posts"},"styles":[]}]}]],["$","$La","fontawesome",{"src":"https://kit.fontawesome.com/110e54d917.js","crossOrigin":"anonymous"}],[["$","$La",null,{"strategy":"afterInteractive","src":"https://www.googletagmanager.com/gtag/js?id=G-RF88KSS1WC"}],["$","$La",null,{"id":"gtag-init","strategy":"afterInteractive","dangerouslySetInnerHTML":{"__html":"\n                  window.dataLayer = window.dataLayer || [];\n                  function gtag(){dataLayer.push(arguments);}\n                  gtag('js', new Date());\n                  gtag('config', 'G-RF88KSS1WC', {\n                    page_path: window.location.pathname,\n                  });\n                "}}]]]}]}],null]
3:[["$","meta","0",{"charSet":"utf-8"}],["$","title","1",{"children":"useEffect 제대로 사용하기 - oungo"}],["$","meta","2",{"name":"description","content":"이번 포스팅에서는 useEffect를 사용하며 놓칠 수 있는 부분과 올바르게 사용하는 방법에 대해 알아보겠습니다."}],["$","meta","3",{"name":"viewport","content":"width=device-width, initial-scale=1"}],["$","meta","4",{"name":"google-site-verification","content":"534XJKqxYeaV4SnmLT7bD8BFygYBD2jEsMZFukhcGNw"}],["$","meta","5",{"property":"og:title","content":"useEffect 제대로 사용하기"}],["$","meta","6",{"property":"og:description","content":"이번 포스팅에서는 useEffect를 사용하며 놓칠 수 있는 부분과 올바르게 사용하는 방법에 대해 알아보겠습니다."}],["$","meta","7",{"property":"og:url","content":"https://oungo.github.io/posts/useEffect"}],["$","meta","8",{"property":"og:image","content":"https://oungo.github.io/og-image.svg"}],["$","meta","9",{"property":"og:image:width","content":"1200"}],["$","meta","10",{"property":"og:image:height","content":"630"}],["$","meta","11",{"name":"twitter:card","content":"summary_large_image"}],["$","meta","12",{"name":"twitter:title","content":"useEffect 제대로 사용하기"}],["$","meta","13",{"name":"twitter:description","content":"이번 포스팅에서는 useEffect를 사용하며 놓칠 수 있는 부분과 올바르게 사용하는 방법에 대해 알아보겠습니다."}],["$","meta","14",{"name":"twitter:image","content":"https://oungo.github.io/og-image.svg"}],["$","link","15",{"rel":"icon","href":"/favicon.ico","type":"image/x-icon","sizes":"16x16"}],["$","link","16",{"rel":"icon","href":"/icon1.png?8fb7eecf67fe01e8","type":"image/png","sizes":"16x16"}],["$","link","17",{"rel":"icon","href":"/icon2.png?e043058d2ad29a8c","type":"image/png","sizes":"32x32"}],["$","link","18",{"rel":"apple-touch-icon","href":"/apple-icon.png?f59fae947b3e763d","type":"image/png","sizes":"180x180"}]]
b:I{"id":5992,"chunks":["719:static/chunks/719-89a63a9863332c2a.js","333:static/chunks/app/posts/[slug]/page-7d9970938d3a476c.js"],"name":"","async":false}
c:T6159,<p>이번 포스팅에서는 useEffect를 사용하며 놓칠 수 있는 부분과 올바르게 사용하는 방법에 대해 알아보겠습니다.</p>
<p>리액트를 사용하는 개발자라면 이미 알고 있는 내용일 수도 있겠지만 다시 한번 정리한다고 생각하고 편하게 봐주시면 좋을 것 같습니다.</p>
<h2>useEffect에서 사용하는 모든 값은 반드시 의존성 배열에 포함하기.</h2>
<p>useEffect뿐만 아니라 useMemo나 useCallback 등을 사용할 때도 반드시 지켜야 하는 규칙입니다.</p>
<p><strong>의존성 배열에 들어가는 값은 선택하는 게 아니고, useEffect에서 사용하는 모든 값을 포함해야 합니다.</strong></p>
<p>여기서 이야기하는 값은 props, state, 컴포넌트 내부에 정의된 모든 변수와 함수를 의미합니다.</p>
<p>왜 위와 같은 규칙을 지켜야 할까요? 간단한 예시를 보여드리겠습니다.</p>
<p>버튼으로 increment를 변경하고, 변경된 increment만큼 증가하는 count를 보여주는 Timer 컴포넌트입니다.</p>
<pre><code class="language-tsx">import { useState, useEffect } from 'react';

export default function Timer() {
  const [count, setCount] = useState(0);
  const [increment, setIncrement] = useState(1);

  function onTick() {
    setCount(count + increment);
  }

  useEffect(() => {
    const id = setInterval(onTick, 1000);
    return () => clearInterval(id);
  }, []);

  return (
    &#x3C;>
      &#x3C;h1>
        Counter: {count}
        &#x3C;button onClick={() => setCount(0)}>Reset&#x3C;/button>
      &#x3C;/h1>
      &#x3C;hr />
      &#x3C;p>
        Every second, increment by:
        &#x3C;button disabled={increment === 0} onClick={() => setIncrement(i => i - 1)}>
          –
        &#x3C;/button>
        &#x3C;b>{increment}&#x3C;/b>
        &#x3C;button onClick={() => setIncrement(i => i + 1)}>+&#x3C;/button>
      &#x3C;/p>
    &#x3C;/>
  );
}
</code></pre>
<p>컴포넌트가 처음 마운트 됐을 때만 타이머를 등록하고 싶다는 생각에 위와 같은 코드를 작성하는 경우가 있습니다.</p>
<p>useEffect에서 사용하는 모든 값은 의존성 배열에 포함되어야 한다는 규칙에 어긋난 코드입니다.</p>
<p><code>count</code>는 0에서 1로 한번 변경되고 그 이후로 변경되지 않습니다.</p>
<p>첫 렌더링시 <code>onTick</code>에서 <code>count</code>를 변경할 때 사용되는 <code>count</code>와 <code>increment</code> 값은 각각 <code>useState</code> 초갓값인 0과 1입니다.</p>
<p>useEffect에서 매초마다 <code>onTick</code>를 호출하고 있지만 의존성 배열에는 빈 배열이 전달되고 있기 때문에 <code>onTick</code>에서는 매번 <code>setCount(0 + 1)</code>을 호출합니다.</p>
<p>이와 같은 이유로 <code>count</code>는 1에서 변경되지 않습니다.</p>
<p>문제를 해결하기 위해 <code>onTick</code> 함수를 의존성 배열에 추가해야 합니다.</p>
<p><a href="https://www.npmjs.com/package/eslint-plugin-react-hooks">eslint-plugin-react-hooks</a>를 활용하면 의존성 배열에 필요한 값이 누락될 경우 linter가 경고해 주기 때문에 위와 같은 실수를 방지할 수 있습니다.</p>
<p>아래와 같이 linter를 무시하는 주석을 사용하는 경우도 있습니다. 하지만 언제나 linter를 무시하는 방법이 아닌 더 나은 해결책이 있을 겁니다.</p>
<pre><code class="language-tsx">useEffect(() => {
  // eslint-ignore-next-line react-hooks/exhaustive-deps
}, []);
</code></pre>
<h2>cleanup function 활용하기.</h2>
<p>A 컴포넌트가 처음 마운트 되면 채팅 서버와 커넥션을 맺는다고 가정해 봅시다.</p>
<p>A 컴포넌트가 렌더링 되면 useEffect가 호출되고, 채팅 서버와 연결이 됩니다.</p>
<p>사용자는 다른 페이지로 이동했다가 다시 A 컴포넌트가 있는 페이지로 이동합니다.</p>
<p>다시 useEffect가 호출되면서 다시 연결을 시도하는데 첫 번째 연결은 사라지지 않은 상태로 이루어집니다.</p>
<p>이런 동작이 여러 번 반복되면 계속해서 커넥션 연결을 시도하게 되고 버그를 발생시킬 수 있습니다.</p>
<pre><code class="language-tsx">export default function A() {
  useEffect(() => {
    const connection = createConnection();
    connection.connect();
  }, []);
  return &#x3C;h1>Welcome to the chat!&#x3C;/h1>;
}
</code></pre>
<p>이와 같은 문제를 해결하기 위해 cleanup function을 활용할 수 있습니다.</p>
<pre><code class="language-tsx">export default function A() {
  useEffect(() => {
    // setup function
    const connection = createConnection();
    connection.connect();
    // cleanup function
    return () => {
      connection.disconnect();
    };
  }, []);
  return &#x3C;h1>Welcome to the chat!&#x3C;/h1>;
}
</code></pre>
<p>cleanup function은 useEffect가 다시 호출되기 직전, 그리고 컴포넌트가 unmount 될 때 호출됩니다.</p>
<p>리액트는 개발 모드일 때 내부적으로 컴포넌트를 remount 시켜서 위와 같은 버그를 예방하도록 합니다.</p>
<p>개발 모드일 때 useEffect는 setup => cleanup => setup 순서로 호출이 되는데 effect가 두 번 호출되면서 이상하게 동작한다면 잘못된 코드라고 볼 수 있습니다.</p>
<p>이를 고치기 위해 코드를 한 번만 호출시키기 위한 방법을 찾기보다는 cleanup function을 활용하여 개발 모드에서도 정상적으로 동작하도록 수정이 되어야 합니다.</p>
<h2>불필요한 useEffect 제거하기.</h2>
<p>불필요하게 useEffect를 사용하는 경우가 있습니다. 몇 가지 예시를 들어보겠습니다.</p>
<h3>props나 state로 계산이 가능한 경우에는 새로운 state를 만들지 말고, 렌더링 단계에서 계산하기.</h3>
<pre><code class="language-tsx">function Form() {
  const [firstName, setFirstName] = useState('Taylor');
  const [lastName, setLastName] = useState('Swift');

  // fullName이라는 state는 불필요한 state 입니다.
  const [fullName, setFullName] = useState('');
  useEffect(() => {
    setFullName(firstName + ' ' + lastName);
  }, [firstName, lastName]);

  // 새로운 state와 effect를 사용하지 말고, 아래와 같은 방식으로 사용 가능합니다.
  const fullName = firstName + ' ' + lastName;
}
</code></pre>
<p>아래의 경우에도 마찬가지로 <code>visibleTodos</code>라는 state를 새로 만들 필요가 없습니다.</p>
<pre><code class="language-tsx">function TodoList({ todos, filter }) {
  const [newTodo, setNewTodo] = useState('');

  const [visibleTodos, setVisibleTodos] = useState([]);
  useEffect(() => {
    setVisibleTodos(getFilteredTodos(todos, filter));
  }, [todos, filter]);

  // 아래 코드만으로 충분합니다.
  const visibleTodos = getFilteredTodos(todos, filter);
}
</code></pre>
<p>만약 <code>getFilteredTodos</code>가 오래 걸리는 작업이라면 useMemo로 memoization 할 수 있습니다.<br>
<code>todos</code>, <code>filter</code>의 변경 사항이 없으면 useMemo 내부의 값을 다시 계산하지 않습니다.<br>
<strong>하지만 대부분의 작업은 useMemo가 필요한 만큼 비용이 많이 들지 않습니다.</strong></p>
<pre><code class="language-tsx">import { useMemo, useState } from 'react';

function TodoList({ todos, filter }) {
  const [newTodo, setNewTodo] = useState('');

  const visibleTodos = useMemo(() => {
    return getFilteredTodos(todos, filter);
  }, [todos, filter]);
}
</code></pre>
<h3>props의 변경에 따라 state를 초기화해야할 경우 key 활용하기.</h3>
<p><code>ProfilePage</code> 컴포넌트는 <code>userId</code>를 prop으로 받고, <code>comment</code>라는 state를 갖고 있습니다.
<code>userId</code>가 변경됨에 따라 <code>comment</code>를 초기화하기 위해 useEffect를 사용하는 경우가 있습니다.</p>
<pre><code class="language-tsx">export default function ProfilePage({ userId }) {
  const [comment, setComment] = useState('');

  useEffect(() => {
    setComment('');
  }, [userId]);
}
</code></pre>
<p>이때 useEffect 대신에 key를 활용할 수 있습니다.</p>
<p>리액트는 동일한 컴포넌트가 동일한 위치에 렌더링 될 때 상태가 유지됩니다.</p>
<p><code>userId</code>를 <code>Profile</code> 컴포넌트의 key로 전달하면 리액트는 서로 다른 <code>userId</code>를 가진 컴포넌트를 각각 다른 컴포넌트로 취급합니다.</p>
<p>따라서 key가 변경될 때마다 DOM을 다시 그리고 <code>Profile</code> 컴포넌트의 state를 초기화합니다.</p>
<pre><code class="language-tsx">export default function ProfilePage({ userId }) {
  return &#x3C;Profile userId={userId} key={userId} />;
}

function Profile({ userId }) {
  // comment를 포함하여 Profile 컴포넌트에 정의된 모든 state는 key가 변경되면 초기화 됩니다.
  const [comment, setComment] = useState('');
}
</code></pre>
<h2>의존성 제거하기</h2>
<p>포스팅 초반에 useEffect에서 사용하는 모든 값은 의존성 배열에 추가해야 한다고 설명했습니다.</p>
<p>하지만 여러 가지 값들이 의존성 배열에 담겨있다면 useEffect가 불필요하게 많이 호출되거나 심한 경우 무한 호출이 발생할 수도 있습니다.</p>
<p>따라서 필요한 시점에만 useEffect를 호출하기 위해 불필요한 의존성을 줄여야 합니다. 이를 위한 몇 가지 방법을 설명해 드리겠습니다.</p>
<h3>이벤트 핸들러로 옮길 수 있는 코드인지 확인.</h3>
<p>먼저 useEffect가 정말 필요한 상황이 맞는지 생각해 볼 수 있습니다.</p>
<p>아래 예시처럼 <code>submitted</code>라는 state를 두고, 폼을 제출하면 <code>submitted</code>를 변경하고 useEffect에서 <code>submitted</code>에 따라 post 요청을 보내 코드가 있습니다.</p>
<pre><code class="language-tsx">function Form() {
  const [submitted, setSubmitted] = useState(false);

  useEffect(() => {
    if (submitted) {
      post('/api/register');
      showNotification('Successfully registered!');
    }
  }, [submitted]);

  function handleSubmit() {
    setSubmitted(true);
  }

  // ...
}
</code></pre>
<p>예를 들어 <code>showNotification</code>의 변경 사항으로 <code>theme</code>를 받아서 <code>theme</code>에 따라 다른 스타일의 notification 메시지를 보여준다고 가정해 봅시다.</p>
<p>그럼 <code>showNotification</code>에 <code>theme</code>를 인자로 전달해야 하므로 useEffect의 의존성 배열에도 추가해야 합니다.</p>
<p>이 경우에는 <code>theme</code>만 변경이 되어도 post 요청이 보내지게 됩니다.</p>
<pre><code class="language-tsx">function Form() {
  const [submitted, setSubmitted] = useState(false);
  const theme = useContext(ThemeContext);

  useEffect(() => {
    if (submitted) {
      post('/api/register');
      showNotification('Successfully registered!', theme);
    }
  }, [submitted, theme]);

  function handleSubmit() {
    setSubmitted(true);
  }

  // ...
}
</code></pre>
<p>위와 같은 코드는 버그를 만들어 낼 수 있습니다. 따라서 useEffect가 아닌 이벤트 핸들러에서 동작하는 게 더 올바른 코드입니다.</p>
<p>useEffect를 사용하기 전에 필요한 상황인지 다시 한번 생각해보세요.</p>
<p>특정 인터렉션에 따른 동작일 경우에는 이벤트 핸들러를 활용하는 게 더 나은 방법일 수 있습니다.</p>
<pre><code class="language-tsx">function Form() {
  const theme = useContext(ThemeContext);

  function handleSubmit() {
    post('/api/register');
    showNotification('Successfully registered!', theme);
  }

  // ...
}
</code></pre>
<h3>useEffect 분리하기</h3>
<p>useEffect는 목적에 따라 분리해야 합니다.</p>
<p>아래 코드는 하나의 useEffect에서 <code>cities</code>와 <code>areas</code> 데이터를 가져오고 있습니다.</p>
<p>특정 상태(country, city) 변화에 따라 관련 없는 API를 호출하게 될 수도 있고, 이는 버그로 이어질 수도 있습니다.</p>
<pre><code class="language-tsx">function ShippingForm({ country }) {
  const [cities, setCities] = useState(null);
  const [city, setCity] = useState(null);
  const [areas, setAreas] = useState(null);

  useEffect(() => {
    let ignore = false;
    fetch(`/api/cities?country=${country}`)
      .then(response => response.json())
      .then(json => {
        if (!ignore) {
          setCities(json);
        }
      });

    if (city) {
      fetch(`/api/areas?city=${city}`)
        .then(response => response.json())
        .then(json => {
          if (!ignore) {
            setAreas(json);
          }
        });
    }
    return () => {
      ignore = true;
    };
  }, [country, city]);

</code></pre>
<p>이런 경우에는 서로 관련 있는 부분끼리 묶어서 분리할 수 있습니다.</p>
<p><code>country</code>에 의존하는 useEffect와 <code>city</code>에 의존하는 useEffect 두 개로 분리했습니다.</p>
<p>목적에 따라 useEffect를 분리하였고, 각각 다른 의존성을 갖고 있어 서로의 코드에 영향을 주지 않습니다.</p>
<p>이렇게 함으로써 의도하지 않은 useEffect 호출을 방지할 수 있습니다.</p>
<pre><code class="language-tsx">function ShippingForm({ country }) {
  const [cities, setCities] = useState(null);
  useEffect(() => {
    let ignore = false;
    fetch(`/api/cities?country=${country}`)
      .then(response => response.json())
      .then(json => {
        if (!ignore) {
          setCities(json);
        }
      });
    return () => {
      ignore = true;
    };
  }, [country]);

  const [city, setCity] = useState(null);
  const [areas, setAreas] = useState(null);
  useEffect(() => {
    if (city) {
      let ignore = false;
      fetch(`/api/areas?city=${city}`)
        .then(response => response.json())
        .then(json => {
          if (!ignore) {
            setAreas(json);
          }
        });
      return () => {
        ignore = true;
      };
    }
  }, [city]);
}
</code></pre>
<p>코드가 더 길어지긴 했지만, 이전과는 다르게 불필요한 API 호출도 일어나지 않고, 코드를 파악하고, 유지보수하기에도 용이해졌습니다.</p>
<p>하나의 useEffect가 한 가지 이상의 목적을 갖고 있다면 분리해 주세요.</p>
<h3>updater function 활용하기.</h3>
<p>useEffect에서 상태 변경을 위해 현재 상태를 사용해야 할 경우 <a href="https://react.dev/learn/queueing-a-series-of-state-updates">updater function</a>을 활용할 수 있습니다.</p>
<p>아래 코드에서 메시지를 받으면 기존의 <code>messages</code>와 새로 받은 메시지를 합쳐 <code>message</code> 상태를 변경합니다.</p>
<p><code>messages</code>가 의존성 배열에도 들어가 있고, 문제가 없어 보입니다.</p>
<pre><code class="language-tsx">function ChatRoom({ roomId }) {
  const [messages, setMessages] = useState([]);
  useEffect(() => {
    const connection = createConnection();
    connection.connect();
    connection.on('message', (receivedMessage) => {
      setMessages([...messages, receivedMessage]);
    });
    return () => connection.disconnect();
  }, [roomId, messages]);
  // ...
</code></pre>
<p>위 코드에서 메시지를 받으면 <code>messages</code>를 변경하는데 <code>messages</code>가 변경되었기 때문에 다시 useEffect를 호출합니다.</p>
<p>다시 useEffect를 호출하기 전에 cleanup function 부분이 실행되기 떄문에 <code>connection</code>이 끊겼다가 다시 연결됩니다.</p>
<p>결국 메시지를 받을 때마다 <code>connection</code>이 끊겼다가 다시 연결 시도하는 문제가 발생합니다.</p>
<p>이때 updater function을 활용할 수 있습니다.</p>
<p><code>setMessages</code>에 updater function을 전달함으로써 의존성 배열에 있는 <code>messages</code>를 제거할 수 있습니다.</p>
<p>이제 <code>messages</code>의 변경에 따라 useEffect가 다시 호출되지 않습니다.</p>
<p>이처럼 기존의 state를 이용해서 새로운 state를 만들어야 할 경우 updater function을 활용할 수 있습니다.</p>
<pre><code class="language-tsx">function ChatRoom({ roomId }) {
  const [messages, setMessages] = useState([]);
  useEffect(() => {
    const connection = createConnection();
    connection.connect();
    connection.on('message', (receivedMessage) => {
      setMessages(msgs => [...msgs, receivedMessage]);
    });
    return () => connection.disconnect();
  }, [roomId]);
  // ...
</code></pre>
<h3>객체나 함수는 컴포넌트 외부나 useEffect 내부에 선언하기.</h3>
<p>가능하면 객체나 함수는 의존성 배열에 포함하지 않는 것이 좋습니다.</p>
<p>그 이유는 컴포넌트 내부에 있는 객체나 함수는 렌더링마다 새로 생성되기 때문입니다.</p>
<p>이로인해 의도치 않은 useEffect 호출이 여러 번 발생할 수 있습니다.</p>
<p>아래 ChatRoom 컴포넌트는 다음과 같이 동작합니다.</p>
<ol>
<li>input이 변경될 때마다 컴포넌트 리렌더링.</li>
<li>렌더링마다 <code>options</code> 새로 생성.</li>
<li><code>options</code>의 변경에 따라 useEffect 호출.</li>
</ol>
<p>결국 input의 변경이 매번 connection을 다시 만드는 잘못된 동작을 만들어 내고 있습니다.</p>
<pre><code class="language-tsx">const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId }) {
  const [message, setMessage] = useState('');

  const options = {
    serverUrl: serverUrl,
    roomId: roomId,
  };

  useEffect(() => {
    const connection = createConnection(options);
    connection.connect();
    return () => connection.disconnect();
  }, [options]);

  return (
    &#x3C;>
      &#x3C;h1>Welcome to the {roomId} room!&#x3C;/h1>
      &#x3C;input value={message} onChange={e => setMessage(e.target.value)} />
    &#x3C;/>
  );
}
</code></pre>
<h4>정적인 객체나 함수는 컴포넌트 외부에 선언.</h4>
<p>이를 막기 위해 정적인 객체나 함수는 컴포넌트 외부에 선언하여 의존성을 제거할 수 있습니다.</p>
<p>만약 <code>options</code>가 정적인 객체라면 컴포넌트 외부에 선언하면 됩니다.</p>
<p>컴포넌트 외부에 선언하면 <code>options</code>는 리렌더링에 따라 변하지 않는 값이기 때문에 의존성 배열에서 제거할 수 있습니다.</p>
<pre><code class="language-tsx">const options = {
  serverUrl: 'https://localhost:1234',
  roomId: 'music'
};

function ChatRoom() {
  const [message, setMessage] = useState('');

  useEffect(() => {
    const connection = createConnection(options);
    connection.connect();
    return () => connection.disconnect();
  }, []);
  // ...
</code></pre>
<p>함수일 경우에도 마찬가지입니다.</p>
<p>컴포넌트에 의존하는 값이 없으면 함수를 컴포넌트 외부에 선언하면 의존성 배열에 추가할 필요가 없습니다.</p>
<pre><code class="language-tsx">function createOptions() {
  return {
    serverUrl: 'https://localhost:1234',
    roomId: 'music'
  };
}

function ChatRoom() {
  const [message, setMessage] = useState('');

  useEffect(() => {
    const options = createOptions();
    const connection = createConnection();
    connection.connect();
    return () => connection.disconnect();
  }, []);
  // ...
</code></pre>
<h4>동적인 객체나 함수는 useEffect 내부에 선언.</h4>
<p>props나 state 등 동적인 값에 의존하는 객체나 함수는 useEffect 내부에 선언하여 의존성을 제거할 수 있습니다.</p>
<p>기존 예시에서는 <code>roomId</code>를 prop으로 전달받고, <code>options</code>는 <code>roomId</code>에 의존하고 있었습니다.</p>
<p>이런 경우에는 <code>options</code>를 <code>useEffect</code> 내부로 옮기면 됩니다.</p>
<pre><code class="language-tsx">const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId }) {
  const [message, setMessage] = useState('');

  useEffect(() => {
    const options = {
      serverUrl: serverUrl,
      roomId: roomId
    };
    const connection = createConnection(options);
    connection.connect();
    return () => connection.disconnect();
  }, [roomId]);
  // ...
</code></pre>
<p><code>options</code>는 useEffect 내부로 옮겼고, <code>roomId</code>를 사용하고 있기 때문에 의존성 배열에 roomId만 추가해 주면 됩니다.</p>
<p>코드에 <code>roomId</code>의 타입은 나와 있지 않지만 primitive 타입이라고 가정합니다.</p>
<p>이제 useEffect가 <code>options</code> 객체가 아닌 <code>roomId</code>에만 의존하고 있기 때문에 이전처럼 <code>message</code> 변경에 따라 useEffect가 호출되지 않습니다.</p>
<p>함수일 경우에도 마찬가지로 useEffect 내부에 선언해 줘서 의존성을 줄이고 불필요한 useEffect 호출을 막을 수 있습니다.</p>
<pre><code class="language-tsx">const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId }) {
  const [message, setMessage] = useState('');

  useEffect(() => {
    function createOptions() {
      return {
        serverUrl: serverUrl,
        roomId: roomId
      };
    }

    const options = createOptions();
    const connection = createConnection(options);
    connection.connect();
    return () => connection.disconnect();
  }, [roomId]);
  // ...
</code></pre>
<p>다시 한번 정리하자면 useEffect에서 사용되는 객체나 함수는 정적인 값일 경우에는 컴포넌트 외부로 옮기고, 동적인 값일 경우에는 useEffect 내부로 옮겨서 의존성을 없애고, 불필요한 호출을 막을 수 있습니다.</p>
<p>가능하면 객체나 함수가 의존성 배열에 포함되지 않도록 해주세요.</p>
<h4>객체나 함수를 props로 전달받는 경우</h4>
<p>물론 useEffect 에서 객체나 함수를 전달받아 사용해야 하는 경우도 있습니다.</p>
<p><code>ChatRoom</code> 컴포넌트는 부모 컴포넌트로부터 <code>options</code>를 props로 받고 있습니다.</p>
<p>이 경우에는 <code>ChatRoom</code>의 부모 컴포넌트가 리렌더링 될 때마다 <code>ChatRoom</code>의 useEffect도 다시 호출됩니다.</p>
<pre><code class="language-tsx">function ChatRoom({ options }) {
  const [message, setMessage] = useState('');

  useEffect(() => {
    const connection = createConnection(options);
    connection.connect();
    return () => connection.disconnect();
  }, [options]);
  // ...
</code></pre>
<pre><code class="language-tsx">&#x3C;ChatRoom
  roomId={roomId}
  options={{
    serverUrl: serverUrl,
    roomId: roomId,
  }}
/>
</code></pre>
<p>위의 경우에는 아래 코드처럼 useEffect 외부에서 <code>options</code>를 구조 분해 할당 해주고, useEffect 내부에서 다시 객체를 만들어 줍니다.</p>
<p>다소 어색한 느낌이 들긴 하지만 useEffect가 의존하는 값을 명시적으로 확인할 수 있고, 부모 컴포넌트의 리렌더링에 따라 useEffect가 호출돼서 connection이 끊길 일도 없습니다.</p>
<pre><code class="language-tsx">function ChatRoom({ options }) {
  const [message, setMessage] = useState('');

  const { roomId, serverUrl } = options;
  useEffect(() => {
    const connection = createConnection({
      roomId: roomId,
      serverUrl: serverUrl
    });
    connection.connect();
    return () => connection.disconnect();
  }, [roomId, serverUrl]);
  // ...
</code></pre>
<h2>마무리</h2>
<p>지금까지 useEffect를 사용하며 놓칠 수 있는 부분과 올바르게 사용할 수 있는 방법에 대해 알아봤습니다.</p>
<p><code>useEffectEvent</code> 훅을 활용하는 방법도 있지만 experimental API라 따로 다루지는 않았습니다.</p>
<p>그래도 대부분의 경우 위에서 설명한 내용들로 대응이 가능할거라 생각합니다.</p>
<p>사실 위에서 작성한 내용은 리액트 <a href="https://react.dev/">공식 문서</a>에 전부 있는 내용입니다.</p>
<p>더욱 자세한 설명이 필요하다면 직접 공식 문서를 정독해보시는 걸 추천드리면서 포스팅을 마칩니다.</p>
<p>봐주셔서 감사합니다.</p>
<h2>참고자료</h2>
<p><a href="https://react.dev/learn/synchronizing-with-effects">synchronizing-with-effects</a></p>
<p><a href="https://react.dev/learn/you-might-not-need-an-effect">you-might-not-need-an-effect</a></p>
<p><a href="https://react.dev/learn/lifecycle-of-reactive-effects">lifecycle-of-reactive-effects</a></p>
<p><a href="https://react.dev/learn/removing-effect-dependencies">removing-effect-dependencies</a></p>
9:["$","article",null,{"children":[["$","h1",null,{"className":"text-3xl font-extrabold","children":"useEffect 제대로 사용하기"}],["$","time",null,{"className":"text-gray-500 font-extralight","dateTime":"2023-10-05","children":"2023 October 5"}],["$","$Lb",null,{"content":"$c"}]]}]
8:null
