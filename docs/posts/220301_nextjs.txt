1:HL["/_next/static/css/9b86d158957fd71b.css","style"]
0:["OF2cciw0uftW_cRfj0QSj",[[["",{"children":["posts",{"children":[["slug","220301_nextjs","d"],{"children":["__PAGE__?{\"slug\":\"220301_nextjs\"}",{}]}]}]},"$undefined","$undefined",true],"$L2",[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/9b86d158957fd71b.css","precedence":"next"}]],"$L3"]]]]
4:HL["/_next/static/css/f68b3b8746d2b056.css","style"]
5:I{"id":4882,"chunks":["724:static/chunks/724-09e481ac835dbe53.js","185:static/chunks/app/layout-a7cbd0974d1665dc.js"],"name":"","async":false}
6:I{"id":1443,"chunks":["272:static/chunks/webpack-250c8836cd5e2c94.js","971:static/chunks/fd9d1056-201df9ae58bf336d.js","864:static/chunks/864-0be03c861a542b53.js"],"name":"","async":false}
7:I{"id":8639,"chunks":["272:static/chunks/webpack-250c8836cd5e2c94.js","971:static/chunks/fd9d1056-201df9ae58bf336d.js","864:static/chunks/864-0be03c861a542b53.js"],"name":"","async":false}
a:I{"id":4244,"chunks":["724:static/chunks/724-09e481ac835dbe53.js","185:static/chunks/app/layout-a7cbd0974d1665dc.js"],"name":"","async":false}
2:[null,["$","html",null,{"lang":"ko","children":["$","body",null,{"children":[[["$","$L5",null,{}],["$","main",null,{"className":"max-w-screen-md px-5 py-20 m-auto","children":["$","$L6",null,{"parallelRouterKey":"children","segmentPath":["children"],"loading":"$undefined","loadingStyles":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","template":["$","$L7",null,{}],"templateStyles":"$undefined","notFound":[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":"404"}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]],"notFoundStyles":[],"childProp":{"current":["$","$L6",null,{"parallelRouterKey":"children","segmentPath":["children","posts","children"],"loading":"$undefined","loadingStyles":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","template":["$","$L7",null,{}],"templateStyles":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","childProp":{"current":["$","$L6",null,{"parallelRouterKey":"children","segmentPath":["children","posts","children",["slug","220301_nextjs","d"],"children"],"loading":"$undefined","loadingStyles":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","template":["$","$L7",null,{}],"templateStyles":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","childProp":{"current":["$L8","$L9",null],"segment":"__PAGE__?{\"slug\":\"220301_nextjs\"}"},"styles":[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/f68b3b8746d2b056.css","precedence":"next"}]]}],"segment":["slug","220301_nextjs","d"]},"styles":[]}],"segment":"posts"},"styles":[]}]}]],["$","$La","fontawesome",{"src":"https://kit.fontawesome.com/110e54d917.js","crossOrigin":"anonymous"}],[["$","$La",null,{"strategy":"afterInteractive","src":"https://www.googletagmanager.com/gtag/js?id=undefined"}],["$","$La",null,{"id":"gtag-init","strategy":"afterInteractive","dangerouslySetInnerHTML":{"__html":"\n                  window.dataLayer = window.dataLayer || [];\n                  function gtag(){dataLayer.push(arguments);}\n                  gtag('js', new Date());\n                  gtag('config', 'undefined', {\n                    page_path: window.location.pathname,\n                  });\n                "}}]]]}]}],null]
3:[["$","meta","0",{"charSet":"utf-8"}],["$","title","1",{"children":"Next.js SSG, SSR, ISR - oungo"}],["$","meta","2",{"name":"description","content":"코로나 격리기간 중 할게 없어서 간만에 Next.js 문서 정독을 했다. 모든 기능을 설명하에는 글이 너무 길어질것 같고, Next.js에서 가장 핵심이라고 할 수 있는 SSG, SSR, ISR에 대해 정리해보려고 한다."}],["$","meta","3",{"name":"viewport","content":"width=device-width, initial-scale=1"}],["$","meta","4",{"name":"google-site-verification","content":"534XJKqxYeaV4SnmLT7bD8BFygYBD2jEsMZFukhcGNw"}],["$","meta","5",{"property":"og:title","content":"Next.js SSG, SSR, ISR"}],["$","meta","6",{"property":"og:description","content":"코로나 격리기간 중 할게 없어서 간만에 Next.js 문서 정독을 했다. 모든 기능을 설명하에는 글이 너무 길어질것 같고, Next.js에서 가장 핵심이라고 할 수 있는 SSG, SSR, ISR에 대해 정리해보려고 한다."}],["$","meta","7",{"property":"og:url","content":"https://oungo.github.io/posts/220301_nextjs"}],["$","meta","8",{"property":"og:image","content":"https://oungo.github.io/og-image.svg"}],["$","meta","9",{"property":"og:image:width","content":"1200"}],["$","meta","10",{"property":"og:image:height","content":"630"}],["$","meta","11",{"name":"twitter:card","content":"summary_large_image"}],["$","meta","12",{"name":"twitter:title","content":"Next.js SSG, SSR, ISR"}],["$","meta","13",{"name":"twitter:description","content":"코로나 격리기간 중 할게 없어서 간만에 Next.js 문서 정독을 했다. 모든 기능을 설명하에는 글이 너무 길어질것 같고, Next.js에서 가장 핵심이라고 할 수 있는 SSG, SSR, ISR에 대해 정리해보려고 한다."}],["$","meta","14",{"name":"twitter:image","content":"https://oungo.github.io/og-image.svg"}],["$","link","15",{"rel":"icon","href":"/favicon.ico","type":"image/x-icon","sizes":"16x16"}],["$","link","16",{"rel":"icon","href":"/icon1.png?8fb7eecf67fe01e8","type":"image/png","sizes":"16x16"}],["$","link","17",{"rel":"icon","href":"/icon2.png?e043058d2ad29a8c","type":"image/png","sizes":"32x32"}],["$","link","18",{"rel":"apple-touch-icon","href":"/apple-icon.png?f59fae947b3e763d","type":"image/png","sizes":"180x180"}]]
b:I{"id":5992,"chunks":["719:static/chunks/719-89a63a9863332c2a.js","333:static/chunks/app/posts/[slug]/page-4428393b44ddc828.js"],"name":"","async":false}
c:T285f,<p>코로나 격리 기간에 할 게 없어서 간만에 Next.js 문서 정독을 했다. 모든 기능을 설명하기에는 글이 너무 길어질 것 같고, Next.js에서 가장 핵심이라고 할 수 있는 SSG, SSR, ISR에 대해 정리해보려고 한다.</p>
<h2>Next.js</h2>
<p>Next.js는 리액트 프레임워크다. 서버 사이드 렌더링이나 다이나믹 라우팅 등 리액트 어플리케이션을 개발할 때 필요한 기능들을 쉽게 사용할 수 있도록 도와주는 역할을 한다. 이는 Next.js에서 요구하는 조건에 맞춰서 코드를 작성하기만 하면 된다. 서버 사이드 렌더링과 클라이언트 사이드 렌더링의 차이는 아래 이미지로 확인할 수 있다.</p>
<p><img src="/assets/blog/nextjs/ssr.png" alt="ssr">
<img src="/assets/blog/nextjs/csr.png" alt="csr">
출처 <a href="https://medium.com/walmartglobaltech/the-benefits-of-server-side-rendering-over-client-side-rendering-5d07ff2cefe8">The Benefits of Server Side Rendering Over Client Side Rendering</a></p>
<h2>Pre-rendering</h2>
<p>Next.js에서 가장 중요한 컨셉 중 하나가 Pre-rendering이다. 각 페이지의 HTML을 미리 만들어 놓는다는 뜻이다. pre-rendeing이 발생하는지는 간단한 테스트를 통해 확인해 볼 수 있다.</p>
<ol>
<li>
<p>먼저 <code>npx create-next-app nextjs-example</code> 명령어를 통해 Next.js 기본 프로젝트를 만들어주고, 실행한다.</p>
</li>
<li>
<p>크롬 개발자 모드를 켜고, command + shift + p를 눌러서 disable javascript를 누르고 새로고침을 한다. 그러면 자바스크립트를 실행하지 않아도 미리 만들어둔 Html을 보여줌으로써 어플리케이션의 ui를 확인할 수 있습니다.</p>
</li>
<li>
<p>똑같은 방식으로 <code>create-react-app</code> 프로젝트를 만들어서 비교해 보면 둘의 차이를 알 수 있다.</p>
</li>
</ol>
<h2>Static Generation, Server-side Rendering</h2>
<p>Pre-rendering은 크게 두 가지 방식으로 나뉠 수 있는데 Static Generation과 Server-side Rendering이다. 공식 문서에 아래와 같이 설명하고 있다.</p>
<blockquote>
<p><code>Static Generation</code> is the pre-rendering method that generates the HTML at <code>build time</code>. The pre-rendered HTML is then reused on each request.</p>
</blockquote>
<blockquote>
<p><code>Server-side Rendering</code> is the pre-rendering method that generates the HTML on <code>each request</code>.</p>
</blockquote>
<p>다시 설명하면 Static Generation은 빌드 할 때 HTML을 생성해놓고, 요청이 들어오면 빌드 할 때 만들어둔 HTML을 보여준다. Server-side Rendering은 매 요청 시 HTML을 생성해서 보여준다.</p>
<h2>getStaticProps</h2>
<p>Next.js에서는 Static Generation 사용을 권장한다. 사용자의 요청과는 관계없이 보여줄 수 있는 페이지라면 Static Generation을 사용하면 된다. Static Generation 사용 방식은 간단하다.</p>
<p>아래와 같이 getStaticProps을 작성하면 Next.js는 빌드 할 때 getStaticProps로부터 리턴된 props를 사용하여 해당 페이지를 pre-render 한다.</p>
<pre><code class="language-typescript">export default function Home(props) { ... }

export async function getStaticProps() {
  const data = { name: 'haha' };

  return {
    props: {
      data
    }
  }
}
</code></pre>
<p>getStaticProps는 서버사이드에서만 실행된다. javascript bundle에도 포함되지 않는다. 따라서 브라우저를 통하지 않고, getStaticProps 내에서 바로 쿼리를 호출하여 데이터를 가져올 수 있다.</p>
<h2>getServerSideProps</h2>
<p>Server-side Rendering의 사용법도 비슷하다. getStaticProps 대신 getServerSideProps를 사용하면 된다.</p>
<p>아래와 같이 getServerSideProps를 작성하면 매 요청 시마다 getServerSideProps에서 리턴된 데이터를 가지고 해당 페이지를 pre-render 한다. getServerSideProps 또한 서버사이드에서만 실행된다.</p>
<p>getServerSideProps에서 받고 있는 context에는 다양한 데이터가 담겨있는데 자세한 건 <a href="https://nextjs.org/docs/api-reference/data-fetching/get-server-side-props">API 문서</a>를 살펴보자.</p>
<pre><code class="language-typescript">export async function getServerSideProps(context) {
  const data = { name: 'haha' };

  return {
    props: {
      data,
    },
  };
}
</code></pre>
<h2>Incremental Static Regeneration(ISR)</h2>
<p>Static Generation은 빌드 할 때 HTML을 만들어 두기 때문에 보통 정적인 데이터를 보여주고자 할 때 사용된다. 하지만 Incremental Static Regeneration을 사용하면 빌드 후에도 변경된 데이터를 가져올 수 있다. getStaticProps에 revalidate prop을 추가하면 된다.</p>
<pre><code class="language-tsx">import styles from '../styles/Home.module.css';
import axios from 'axios';

export default function Home({ data }) {
  return (
    &#x3C;div className={styles.container}>
      &#x3C;h1>{data}&#x3C;/h1>
    &#x3C;/div>
  );
}

export async function getStaticProps() {
  // 현재 시간을 가져오는 API
  const res = await axios.get('https://worldtimeapi.org/api/ip');
  return {
    props: {
      data: res.data.datetime,
    },
  };
}
</code></pre>
<p>위와 같은 코드를 작성하고 빌드 후 실행시키면 시간을 화면에 보여주는데 페이지를 새로고침해도 처음 빌드할 때 getStaticProps를 통해 데이터를 가져왔기 때문에 시간은 바뀌지 않는다.</p>
<p>이번엔 revalidate prop을 추가해 보자.</p>
<pre><code class="language-typescript">export async function getStaticProps() {
  const res = await axios.get('https://worldtimeapi.org/api/ip');

  return {
    props: {
      data: res.data.datetime,
    },
    revalidate: 60,
  };
}
</code></pre>
<p><code>revalidate</code>를 추가하면 Next.js는 요청이 들어왔을 때, 최대 10초에 한 번 페이지 regeneration을 수행할 것이다.</p>
<p>revalidate를 추가했을 때 동작 방식은 다음과 같다.</p>
<ol>
<li>
<p>페이지 요청이 들어오면 캐시 된 페이지를 보여준다.</p>
</li>
<li>
<p>최초 페이지 요청 후 60초 내로 들어오는 요청들도 캐시 된 페이지를 보여준다.</p>
</li>
<li>
<p>10 초 후 요청이 들어왔을 때도 저장된 페이지를 보여주고, Next.js는 백그라운드에서 페이지 regeneration을 수행한다.</p>
</li>
<li>
<p>페이지 regeneration이 성공적으로 됐을 경우 이전의 캐시를 없애고 새로운 페이지를 보여준다.</p>
</li>
</ol>
<p><img src="/assets/blog/nextjs/isr.png" alt="ISR">
출처 <a href="https://vercel.com/docs/concepts/next.js/incremental-static-regeneration">Incremental Static Regeneration</a></p>
<p>이처럼 getStaticProps에 revalidate를 사용하면 데이터가 변경되더라도 계속해서 새로운 데이터를 보여줄 수 있다.</p>
<h2>On-Demand Revalidation (Beta)</h2>
<p>ISR를 통해 SSG에서 정적인 데이터만 보여준다는 단점을 보완할 수 있다. 하지만 <code>revalidate</code>를 설정하면 특정 시간 내에는 무조건 동일한 데이터를 가진 페이지를 볼 수밖에 없다. 그 사이에 데이터가 변경된다고 하더라도 새로운 데이터를 확인할 수 있는 유일한 방법은 revalidate에 설정한 시간이 지난 후 누군가 페이지를 요청을 보내는 것뿐이다.</p>
<p>하지만 Next.js <code>v12.1.0</code> 부터는 On-Demand Revalidation을 지원한다. 원하는 시점에 캐시 된 페이지를 지우고 페이지 regeneration이 가능하다.</p>
<p>사용 방법은 기존에 있던 revalidate를 삭제하고, unstable_revalidate를 사용하면 된다.
먼저 pages/api/revalidate.js 파일에 아래와 같은 코드를 넣어준다.</p>
<p>unstable_revalidate에는 revalidate할 페이지를 넣어준다. 여기서는 인덱스 페이지에 적용할 것이기 때문에 '/'를 넣어줬다</p>
<pre><code class="language-typescript">// pages/api/revalidate.js

export default async function handler(req, res) {
  // Check for secret to confirm this is a valid request
  if (req.query.secret !== process.env.MY_SECRET_TOKEN) {
    return res.status(401).json({ message: 'Invalid token' });
  }

  try {
    await res.unstable_revalidate('/');
    return res.json({ revalidated: true });
  } catch (err) {
    // If there was an error, Next.js will continue
    // to show the last successfully generated page
    return res.status(500).send('Error revalidating');
  }
}
</code></pre>
<p>그리고 Home 컴포넌트에서는 revalidate를 수행할 버튼을 만들고 위에서 만든 걸 호출하면 된다.</p>
<pre><code class="language-tsx">import styles from '../styles/Home.module.css';
import axios from 'axios';

export default function Home({ data }) {
  function revalidate() {
    fetch('/api/revalidate');
  }

  return (
    &#x3C;div className={styles.container}>
      &#x3C;h1>{data}&#x3C;/h1>
      &#x3C;button onClick={() => revalidate()}>Revalidate&#x3C;/button>
    &#x3C;/div>
  );
}

export async function getStaticProps() {
  const res = await axios.get('https://worldtimeapi.org/api/ip');
  return {
    props: {
      data: res.data.datetime,
    },
    // revalidate: 5
  };
}
</code></pre>
<p>그럼 아래와 같이 동작한다.
버튼을 누르지 않고 새로고침을 하면 계속 동일한 시간이 나온다.
revalidate 버튼을 누르고, 다시 새로 고침을 누르면 변경된 시간을 확인할 수 있다.</p>
<p><img src="/assets/blog/nextjs/on-demand.gif" alt="ISR"></p>
<h2>마무리</h2>
<p>Next.js에서 가장 핵심이라고 할 수 있는 SSG, SSR, ISR 그리고 가장 최근에 나온 On-Demand Revalidation (Beta)까지 알아보았다. 참고로 전부 page 내에서만 사용이 가능하고, 페이지별로 다르게 적용할 수 있다.</p>
<p>예전에 처음 Next.js로 프로젝트를 시작했을 때는 getInitialProps밖에 없었던 걸로 기억하는데 그동안 많이 바뀐 것 같다. Next.js를 사용해 보지 않았다면 한번쯤 사용해 보는 것을 추천한다. 사용법도 간단하고 문서도 굉장히 잘 되어있기 때문에 초보자가 접근하기에도 무리가 없을 거라고 생각한다.</p>
9:["$","article",null,{"children":[["$","h1",null,{"className":"text-3xl font-extrabold","children":"Next.js SSG, SSR, ISR"}],["$","time",null,{"className":"text-gray-500 font-extralight","dateTime":"2022-03-01","children":"2022 March 1"}],["$","$Lb",null,{"content":"$c"}]]}]
8:null
