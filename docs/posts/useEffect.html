<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/_next/static/css/9b86d158957fd71b.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/f68b3b8746d2b056.css" data-precedence="next"/><link rel="preload" href="/_next/static/chunks/webpack-250c8836cd5e2c94.js" as="script" fetchPriority="low"/><script src="/_next/static/chunks/fd9d1056-201df9ae58bf336d.js" async=""></script><script src="/_next/static/chunks/864-0be03c861a542b53.js" async=""></script><script src="/_next/static/chunks/main-app-aa0a94018ed42b6f.js" async=""></script><link rel="preload" href="https://kit.fontawesome.com/110e54d917.js" as="script"/><link rel="preload" href="https://www.googletagmanager.com/gtag/js?id=G-RF88KSS1WC" as="script"/><title>useEffect 제대로 사용하기 - oungo</title><meta name="description" content="이번 포스팅에서는 useEffect를 사용하며 놓칠 수 있는 부분과 올바르게 사용하는 방법에 대해 알아보겠습니다."/><meta property="og:title" content="useEffect 제대로 사용하기"/><meta property="og:description" content="이번 포스팅에서는 useEffect를 사용하며 놓칠 수 있는 부분과 올바르게 사용하는 방법에 대해 알아보겠습니다."/><meta property="og:url" content="https://oungo.github.io/posts/useEffect"/><meta property="og:image" content="https://oungo.github.io/og-image.svg"/><meta property="og:image:width" content="1200"/><meta property="og:image:height" content="630"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="useEffect 제대로 사용하기"/><meta name="twitter:description" content="이번 포스팅에서는 useEffect를 사용하며 놓칠 수 있는 부분과 올바르게 사용하는 방법에 대해 알아보겠습니다."/><meta name="twitter:image" content="https://oungo.github.io/og-image.svg"/><link rel="icon" href="/favicon.ico" type="image/x-icon" sizes="16x16"/><link rel="icon" href="/icon1.png?8fb7eecf67fe01e8" type="image/png" sizes="16x16"/><link rel="icon" href="/icon2.png?e043058d2ad29a8c" type="image/png" sizes="32x32"/><link rel="apple-touch-icon" href="/apple-icon.png?f59fae947b3e763d" type="image/png" sizes="180x180"/><script src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js" noModule=""></script></head><body><header class="fixed top-0 z-10 w-full max-w-screen-md py-3 m-auto text-3xl font-extrabold text-center -translate-x-1/2 bg-white bg-opacity-30 backdrop-blur-sm left-1/2"><i class="absolute text-xl -translate-y-1/2 cursor-pointer left-5 top-1/2 fa-solid fa-bars"></i><a href="/">oungo</a></header><main class="max-w-screen-md px-5 py-20 m-auto"><article><h1 class="text-3xl font-extrabold">useEffect 제대로 사용하기</h1><time class="text-gray-500 font-extralight" dateTime="2023-10-05">2023 October 5</time><div class="mt-5 markdown-body"><p>이번 포스팅에서는 useEffect를 사용하며 놓칠 수 있는 부분과 올바르게 사용하는 방법에 대해 알아보겠습니다.</p>
<p>리액트를 사용하는 개발자라면 이미 알고 있는 내용일 수도 있겠지만 다시 한번 정리한다고 생각하고 편하게 봐주시면 좋을 것 같습니다.</p>
<h2>useEffect에서 사용하는 모든 값은 반드시 의존성 배열에 포함하기.</h2>
<p>useEffect뿐만 아니라 useMemo나 useCallback 등을 사용할 때도 반드시 지켜야 하는 규칙입니다.</p>
<p><strong>의존성 배열에 들어가는 값은 선택하는 게 아니고, useEffect에서 사용하는 모든 값을 포함해야 합니다.</strong></p>
<p>여기서 이야기하는 값은 props, state, 컴포넌트 내부에 정의된 모든 변수와 함수를 의미합니다.</p>
<p>왜 위와 같은 규칙을 지켜야 할까요? 간단한 예시를 보여드리겠습니다.</p>
<p>버튼으로 increment를 변경하고, 변경된 increment만큼 증가하는 count를 보여주는 Timer 컴포넌트입니다.</p>
<pre><code class="language-tsx">import { useState, useEffect } from 'react';

export default function Timer() {
  const [count, setCount] = useState(0);
  const [increment, setIncrement] = useState(1);

  function onTick() {
    setCount(count + increment);
  }

  useEffect(() => {
    const id = setInterval(onTick, 1000);
    return () => clearInterval(id);
  }, []);

  return (
    &#x3C;>
      &#x3C;h1>
        Counter: {count}
        &#x3C;button onClick={() => setCount(0)}>Reset&#x3C;/button>
      &#x3C;/h1>
      &#x3C;hr />
      &#x3C;p>
        Every second, increment by:
        &#x3C;button disabled={increment === 0} onClick={() => setIncrement(i => i - 1)}>
          –
        &#x3C;/button>
        &#x3C;b>{increment}&#x3C;/b>
        &#x3C;button onClick={() => setIncrement(i => i + 1)}>+&#x3C;/button>
      &#x3C;/p>
    &#x3C;/>
  );
}
</code></pre>
<p>컴포넌트가 처음 마운트 됐을 때만 타이머를 등록하고 싶다는 생각에 위와 같은 코드를 작성하는 경우가 있습니다.</p>
<p>useEffect에서 사용하는 모든 값은 의존성 배열에 포함되어야 한다는 규칙에 어긋난 코드입니다.</p>
<p><code>count</code>는 0에서 1로 한번 변경되고 그 이후로 변경되지 않습니다.</p>
<p>첫 렌더링시 <code>onTick</code>에서 <code>count</code>를 변경할 때 사용되는 <code>count</code>와 <code>increment</code> 값은 각각 <code>useState</code> 초갓값인 0과 1입니다.</p>
<p>useEffect에서 매초마다 <code>onTick</code>를 호출하고 있지만 의존성 배열에는 빈 배열이 전달되고 있기 때문에 <code>onTick</code>에서는 매번 <code>setCount(0 + 1)</code>을 호출합니다.</p>
<p>이와 같은 이유로 <code>count</code>는 1에서 변경되지 않습니다.</p>
<p>문제를 해결하기 위해 <code>onTick</code> 함수를 의존성 배열에 추가해야 합니다.</p>
<p><a href="https://www.npmjs.com/package/eslint-plugin-react-hooks">eslint-plugin-react-hooks</a>를 활용하면 의존성 배열에 필요한 값이 누락될 경우 linter가 경고해 주기 때문에 위와 같은 실수를 방지할 수 있습니다.</p>
<p>아래와 같이 linter를 무시하는 주석을 사용하는 경우도 있습니다. 하지만 언제나 linter를 무시하는 방법이 아닌 더 나은 해결책이 있을 겁니다.</p>
<pre><code class="language-tsx">useEffect(() => {
  // eslint-ignore-next-line react-hooks/exhaustive-deps
}, []);
</code></pre>
<h2>cleanup function 활용하기.</h2>
<p>A 컴포넌트가 처음 마운트 되면 채팅 서버와 커넥션을 맺는다고 가정해 봅시다.</p>
<p>A 컴포넌트가 렌더링 되면 useEffect가 호출되고, 채팅 서버와 연결이 됩니다.</p>
<p>사용자는 다른 페이지로 이동했다가 다시 A 컴포넌트가 있는 페이지로 이동합니다.</p>
<p>다시 useEffect가 호출되면서 다시 연결을 시도하는데 첫 번째 연결은 사라지지 않은 상태로 이루어집니다.</p>
<p>이런 동작이 여러 번 반복되면 계속해서 커넥션 연결을 시도하게 되고 버그를 발생시킬 수 있습니다.</p>
<pre><code class="language-tsx">export default function A() {
  useEffect(() => {
    const connection = createConnection();
    connection.connect();
  }, []);
  return &#x3C;h1>Welcome to the chat!&#x3C;/h1>;
}
</code></pre>
<p>이와 같은 문제를 해결하기 위해 cleanup function을 활용할 수 있습니다.</p>
<pre><code class="language-tsx">export default function A() {
  useEffect(() => {
    // setup function
    const connection = createConnection();
    connection.connect();
    // cleanup function
    return () => {
      connection.disconnect();
    };
  }, []);
  return &#x3C;h1>Welcome to the chat!&#x3C;/h1>;
}
</code></pre>
<p>cleanup function은 useEffect가 다시 호출되기 직전, 그리고 컴포넌트가 unmount 될 때 호출됩니다.</p>
<p>리액트는 개발 모드일 때 내부적으로 컴포넌트를 remount 시켜서 위와 같은 버그를 예방하도록 합니다.</p>
<p>개발 모드일 때 useEffect는 setup => cleanup => setup 순서로 호출이 되는데 effect가 두 번 호출되면서 이상하게 동작한다면 잘못된 코드라고 볼 수 있습니다.</p>
<p>이를 고치기 위해 코드를 한 번만 호출시키기 위한 방법을 찾기보다는 cleanup function을 활용하여 개발 모드에서도 정상적으로 동작하도록 수정이 되어야 합니다.</p>
<h2>불필요한 useEffect 제거하기.</h2>
<p>불필요하게 useEffect를 사용하는 경우가 있습니다. 몇 가지 예시를 들어보겠습니다.</p>
<h3>props나 state로 계산이 가능한 경우에는 새로운 state를 만들지 말고, 렌더링 단계에서 계산하기.</h3>
<pre><code class="language-tsx">function Form() {
  const [firstName, setFirstName] = useState('Taylor');
  const [lastName, setLastName] = useState('Swift');

  // fullName이라는 state는 불필요한 state 입니다.
  const [fullName, setFullName] = useState('');
  useEffect(() => {
    setFullName(firstName + ' ' + lastName);
  }, [firstName, lastName]);

  // 새로운 state와 effect를 사용하지 말고, 아래와 같은 방식으로 사용 가능합니다.
  const fullName = firstName + ' ' + lastName;
}
</code></pre>
<p>아래의 경우에도 마찬가지로 <code>visibleTodos</code>라는 state를 새로 만들 필요가 없습니다.</p>
<pre><code class="language-tsx">function TodoList({ todos, filter }) {
  const [newTodo, setNewTodo] = useState('');

  const [visibleTodos, setVisibleTodos] = useState([]);
  useEffect(() => {
    setVisibleTodos(getFilteredTodos(todos, filter));
  }, [todos, filter]);

  // 아래 코드만으로 충분합니다.
  const visibleTodos = getFilteredTodos(todos, filter);
}
</code></pre>
<p>만약 <code>getFilteredTodos</code>가 오래 걸리는 작업이라면 useMemo로 memoization 할 수 있습니다.<br>
<code>todos</code>, <code>filter</code>의 변경 사항이 없으면 useMemo 내부의 값을 다시 계산하지 않습니다.<br>
<strong>하지만 대부분의 작업은 useMemo가 필요한 만큼 비용이 많이 들지 않습니다.</strong></p>
<pre><code class="language-tsx">import { useMemo, useState } from 'react';

function TodoList({ todos, filter }) {
  const [newTodo, setNewTodo] = useState('');

  const visibleTodos = useMemo(() => {
    return getFilteredTodos(todos, filter);
  }, [todos, filter]);
}
</code></pre>
<h3>props의 변경에 따라 state를 초기화해야할 경우 key 활용하기.</h3>
<p><code>ProfilePage</code> 컴포넌트는 <code>userId</code>를 prop으로 받고, <code>comment</code>라는 state를 갖고 있습니다.
<code>userId</code>가 변경됨에 따라 <code>comment</code>를 초기화하기 위해 useEffect를 사용하는 경우가 있습니다.</p>
<pre><code class="language-tsx">export default function ProfilePage({ userId }) {
  const [comment, setComment] = useState('');

  useEffect(() => {
    setComment('');
  }, [userId]);
}
</code></pre>
<p>이때 useEffect 대신에 key를 활용할 수 있습니다.</p>
<p>리액트는 동일한 컴포넌트가 동일한 위치에 렌더링 될 때 상태가 유지됩니다.</p>
<p><code>userId</code>를 <code>Profile</code> 컴포넌트의 key로 전달하면 리액트는 서로 다른 <code>userId</code>를 가진 컴포넌트를 각각 다른 컴포넌트로 취급합니다.</p>
<p>따라서 key가 변경될 때마다 DOM을 다시 그리고 <code>Profile</code> 컴포넌트의 state를 초기화합니다.</p>
<pre><code class="language-tsx">export default function ProfilePage({ userId }) {
  return &#x3C;Profile userId={userId} key={userId} />;
}

function Profile({ userId }) {
  // comment를 포함하여 Profile 컴포넌트에 정의된 모든 state는 key가 변경되면 초기화 됩니다.
  const [comment, setComment] = useState('');
}
</code></pre>
<h2>의존성 제거하기</h2>
<p>포스팅 초반에 useEffect에서 사용하는 모든 값은 의존성 배열에 추가해야 한다고 설명했습니다.</p>
<p>하지만 여러 가지 값들이 의존성 배열에 담겨있다면 useEffect가 불필요하게 많이 호출되거나 심한 경우 무한 호출이 발생할 수도 있습니다.</p>
<p>따라서 필요한 시점에만 useEffect를 호출하기 위해 불필요한 의존성을 줄여야 합니다. 이를 위한 몇 가지 방법을 설명해 드리겠습니다.</p>
<h3>이벤트 핸들러로 옮길 수 있는 코드인지 확인.</h3>
<p>먼저 useEffect가 정말 필요한 상황이 맞는지 생각해 볼 수 있습니다.</p>
<p>아래 예시처럼 <code>submitted</code>라는 state를 두고, 폼을 제출하면 <code>submitted</code>를 변경하고 useEffect에서 <code>submitted</code>에 따라 post 요청을 보내 코드가 있습니다.</p>
<pre><code class="language-tsx">function Form() {
  const [submitted, setSubmitted] = useState(false);

  useEffect(() => {
    if (submitted) {
      post('/api/register');
      showNotification('Successfully registered!');
    }
  }, [submitted]);

  function handleSubmit() {
    setSubmitted(true);
  }

  // ...
}
</code></pre>
<p>예를 들어 <code>showNotification</code>의 변경 사항으로 <code>theme</code>를 받아서 <code>theme</code>에 따라 다른 스타일의 notification 메시지를 보여준다고 가정해 봅시다.</p>
<p>그럼 <code>showNotification</code>에 <code>theme</code>를 인자로 전달해야 하므로 useEffect의 의존성 배열에도 추가해야 합니다.</p>
<p>이 경우에는 <code>theme</code>만 변경이 되어도 post 요청이 보내지게 됩니다.</p>
<pre><code class="language-tsx">function Form() {
  const [submitted, setSubmitted] = useState(false);
  const theme = useContext(ThemeContext);

  useEffect(() => {
    if (submitted) {
      post('/api/register');
      showNotification('Successfully registered!', theme);
    }
  }, [submitted, theme]);

  function handleSubmit() {
    setSubmitted(true);
  }

  // ...
}
</code></pre>
<p>위와 같은 코드는 버그를 만들어 낼 수 있습니다. 따라서 useEffect가 아닌 이벤트 핸들러에서 동작하는 게 더 올바른 코드입니다.</p>
<p>useEffect를 사용하기 전에 필요한 상황인지 다시 한번 생각해보세요.</p>
<p>특정 인터렉션에 따른 동작일 경우에는 이벤트 핸들러를 활용하는 게 더 나은 방법일 수 있습니다.</p>
<pre><code class="language-tsx">function Form() {
  const theme = useContext(ThemeContext);

  function handleSubmit() {
    post('/api/register');
    showNotification('Successfully registered!', theme);
  }

  // ...
}
</code></pre>
<h3>useEffect 분리하기</h3>
<p>useEffect는 목적에 따라 분리해야 합니다.</p>
<p>아래 코드는 하나의 useEffect에서 <code>cities</code>와 <code>areas</code> 데이터를 가져오고 있습니다.</p>
<p>특정 상태(country, city) 변화에 따라 관련 없는 API를 호출하게 될 수도 있고, 이는 버그로 이어질 수도 있습니다.</p>
<pre><code class="language-tsx">function ShippingForm({ country }) {
  const [cities, setCities] = useState(null);
  const [city, setCity] = useState(null);
  const [areas, setAreas] = useState(null);

  useEffect(() => {
    let ignore = false;
    fetch(`/api/cities?country=${country}`)
      .then(response => response.json())
      .then(json => {
        if (!ignore) {
          setCities(json);
        }
      });

    if (city) {
      fetch(`/api/areas?city=${city}`)
        .then(response => response.json())
        .then(json => {
          if (!ignore) {
            setAreas(json);
          }
        });
    }
    return () => {
      ignore = true;
    };
  }, [country, city]);

</code></pre>
<p>이런 경우에는 서로 관련 있는 부분끼리 묶어서 분리할 수 있습니다.</p>
<p><code>country</code>에 의존하는 useEffect와 <code>city</code>에 의존하는 useEffect 두 개로 분리했습니다.</p>
<p>목적에 따라 useEffect를 분리하였고, 각각 다른 의존성을 갖고 있어 서로의 코드에 영향을 주지 않습니다.</p>
<p>이렇게 함으로써 의도하지 않은 useEffect 호출을 방지할 수 있습니다.</p>
<pre><code class="language-tsx">function ShippingForm({ country }) {
  const [cities, setCities] = useState(null);
  useEffect(() => {
    let ignore = false;
    fetch(`/api/cities?country=${country}`)
      .then(response => response.json())
      .then(json => {
        if (!ignore) {
          setCities(json);
        }
      });
    return () => {
      ignore = true;
    };
  }, [country]);

  const [city, setCity] = useState(null);
  const [areas, setAreas] = useState(null);
  useEffect(() => {
    if (city) {
      let ignore = false;
      fetch(`/api/areas?city=${city}`)
        .then(response => response.json())
        .then(json => {
          if (!ignore) {
            setAreas(json);
          }
        });
      return () => {
        ignore = true;
      };
    }
  }, [city]);
}
</code></pre>
<p>코드가 더 길어지긴 했지만, 이전과는 다르게 불필요한 API 호출도 일어나지 않고, 코드를 파악하고, 유지보수하기에도 용이해졌습니다.</p>
<p>하나의 useEffect가 한 가지 이상의 목적을 갖고 있다면 분리해 주세요.</p>
<h3>updater function 활용하기.</h3>
<p>useEffect에서 상태 변경을 위해 현재 상태를 사용해야 할 경우 <a href="https://react.dev/learn/queueing-a-series-of-state-updates">updater function</a>을 활용할 수 있습니다.</p>
<p>아래 코드에서 메시지를 받으면 기존의 <code>messages</code>와 새로 받은 메시지를 합쳐 <code>message</code> 상태를 변경합니다.</p>
<p><code>messages</code>가 의존성 배열에도 들어가 있고, 문제가 없어 보입니다.</p>
<pre><code class="language-tsx">function ChatRoom({ roomId }) {
  const [messages, setMessages] = useState([]);
  useEffect(() => {
    const connection = createConnection();
    connection.connect();
    connection.on('message', (receivedMessage) => {
      setMessages([...messages, receivedMessage]);
    });
    return () => connection.disconnect();
  }, [roomId, messages]);
  // ...
</code></pre>
<p>위 코드에서 메시지를 받으면 <code>messages</code>를 변경하는데 <code>messages</code>가 변경되었기 때문에 다시 useEffect를 호출합니다.</p>
<p>다시 useEffect를 호출하기 전에 cleanup function 부분이 실행되기 떄문에 <code>connection</code>이 끊겼다가 다시 연결됩니다.</p>
<p>결국 메시지를 받을 때마다 <code>connection</code>이 끊겼다가 다시 연결 시도하는 문제가 발생합니다.</p>
<p>이때 updater function을 활용할 수 있습니다.</p>
<p><code>setMessages</code>에 updater function을 전달함으로써 의존성 배열에 있는 <code>messages</code>를 제거할 수 있습니다.</p>
<p>이제 <code>messages</code>의 변경에 따라 useEffect가 다시 호출되지 않습니다.</p>
<p>이처럼 기존의 state를 이용해서 새로운 state를 만들어야 할 경우 updater function을 활용할 수 있습니다.</p>
<pre><code class="language-tsx">function ChatRoom({ roomId }) {
  const [messages, setMessages] = useState([]);
  useEffect(() => {
    const connection = createConnection();
    connection.connect();
    connection.on('message', (receivedMessage) => {
      setMessages(msgs => [...msgs, receivedMessage]);
    });
    return () => connection.disconnect();
  }, [roomId]);
  // ...
</code></pre>
<h3>객체나 함수는 컴포넌트 외부나 useEffect 내부에 선언하기.</h3>
<p>가능하면 객체나 함수는 의존성 배열에 포함하지 않는 것이 좋습니다.</p>
<p>그 이유는 컴포넌트 내부에 있는 객체나 함수는 렌더링마다 새로 생성되기 때문입니다.</p>
<p>이로인해 의도치 않은 useEffect 호출이 여러 번 발생할 수 있습니다.</p>
<p>아래 ChatRoom 컴포넌트는 다음과 같이 동작합니다.</p>
<ol>
<li>input이 변경될 때마다 컴포넌트 리렌더링.</li>
<li>렌더링마다 <code>options</code> 새로 생성.</li>
<li><code>options</code>의 변경에 따라 useEffect 호출.</li>
</ol>
<p>결국 input의 변경이 매번 connection을 다시 만드는 잘못된 동작을 만들어 내고 있습니다.</p>
<pre><code class="language-tsx">const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId }) {
  const [message, setMessage] = useState('');

  const options = {
    serverUrl: serverUrl,
    roomId: roomId,
  };

  useEffect(() => {
    const connection = createConnection(options);
    connection.connect();
    return () => connection.disconnect();
  }, [options]);

  return (
    &#x3C;>
      &#x3C;h1>Welcome to the {roomId} room!&#x3C;/h1>
      &#x3C;input value={message} onChange={e => setMessage(e.target.value)} />
    &#x3C;/>
  );
}
</code></pre>
<h4>정적인 객체나 함수는 컴포넌트 외부에 선언.</h4>
<p>이를 막기 위해 정적인 객체나 함수는 컴포넌트 외부에 선언하여 의존성을 제거할 수 있습니다.</p>
<p>만약 <code>options</code>가 정적인 객체라면 컴포넌트 외부에 선언하면 됩니다.</p>
<p>컴포넌트 외부에 선언하면 <code>options</code>는 리렌더링에 따라 변하지 않는 값이기 때문에 의존성 배열에서 제거할 수 있습니다.</p>
<pre><code class="language-tsx">const options = {
  serverUrl: 'https://localhost:1234',
  roomId: 'music'
};

function ChatRoom() {
  const [message, setMessage] = useState('');

  useEffect(() => {
    const connection = createConnection(options);
    connection.connect();
    return () => connection.disconnect();
  }, []);
  // ...
</code></pre>
<p>함수일 경우에도 마찬가지입니다.</p>
<p>컴포넌트에 의존하는 값이 없으면 함수를 컴포넌트 외부에 선언하면 의존성 배열에 추가할 필요가 없습니다.</p>
<pre><code class="language-tsx">function createOptions() {
  return {
    serverUrl: 'https://localhost:1234',
    roomId: 'music'
  };
}

function ChatRoom() {
  const [message, setMessage] = useState('');

  useEffect(() => {
    const options = createOptions();
    const connection = createConnection();
    connection.connect();
    return () => connection.disconnect();
  }, []);
  // ...
</code></pre>
<h4>동적인 객체나 함수는 useEffect 내부에 선언.</h4>
<p>props나 state 등 동적인 값에 의존하는 객체나 함수는 useEffect 내부에 선언하여 의존성을 제거할 수 있습니다.</p>
<p>기존 예시에서는 <code>roomId</code>를 prop으로 전달받고, <code>options</code>는 <code>roomId</code>에 의존하고 있었습니다.</p>
<p>이런 경우에는 <code>options</code>를 <code>useEffect</code> 내부로 옮기면 됩니다.</p>
<pre><code class="language-tsx">const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId }) {
  const [message, setMessage] = useState('');

  useEffect(() => {
    const options = {
      serverUrl: serverUrl,
      roomId: roomId
    };
    const connection = createConnection(options);
    connection.connect();
    return () => connection.disconnect();
  }, [roomId]);
  // ...
</code></pre>
<p><code>options</code>는 useEffect 내부로 옮겼고, <code>roomId</code>를 사용하고 있기 때문에 의존성 배열에 roomId만 추가해 주면 됩니다.</p>
<p>코드에 <code>roomId</code>의 타입은 나와 있지 않지만 primitive 타입이라고 가정합니다.</p>
<p>이제 useEffect가 <code>options</code> 객체가 아닌 <code>roomId</code>에만 의존하고 있기 때문에 이전처럼 <code>message</code> 변경에 따라 useEffect가 호출되지 않습니다.</p>
<p>함수일 경우에도 마찬가지로 useEffect 내부에 선언해 줘서 의존성을 줄이고 불필요한 useEffect 호출을 막을 수 있습니다.</p>
<pre><code class="language-tsx">const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId }) {
  const [message, setMessage] = useState('');

  useEffect(() => {
    function createOptions() {
      return {
        serverUrl: serverUrl,
        roomId: roomId
      };
    }

    const options = createOptions();
    const connection = createConnection(options);
    connection.connect();
    return () => connection.disconnect();
  }, [roomId]);
  // ...
</code></pre>
<p>다시 한번 정리하자면 useEffect에서 사용되는 객체나 함수는 정적인 값일 경우에는 컴포넌트 외부로 옮기고, 동적인 값일 경우에는 useEffect 내부로 옮겨서 의존성을 없애고, 불필요한 호출을 막을 수 있습니다.</p>
<p>가능하면 객체나 함수가 의존성 배열에 포함되지 않도록 해주세요.</p>
<h4>객체나 함수를 props로 전달받는 경우</h4>
<p>물론 useEffect 에서 객체나 함수를 전달받아 사용해야 하는 경우도 있습니다.</p>
<p><code>ChatRoom</code> 컴포넌트는 부모 컴포넌트로부터 <code>options</code>를 props로 받고 있습니다.</p>
<p>이 경우에는 <code>ChatRoom</code>의 부모 컴포넌트가 리렌더링 될 때마다 <code>ChatRoom</code>의 useEffect도 다시 호출됩니다.</p>
<pre><code class="language-tsx">function ChatRoom({ options }) {
  const [message, setMessage] = useState('');

  useEffect(() => {
    const connection = createConnection(options);
    connection.connect();
    return () => connection.disconnect();
  }, [options]);
  // ...
</code></pre>
<pre><code class="language-tsx">&#x3C;ChatRoom
  roomId={roomId}
  options={{
    serverUrl: serverUrl,
    roomId: roomId,
  }}
/>
</code></pre>
<p>위의 경우에는 아래 코드처럼 useEffect 외부에서 <code>options</code>를 구조 분해 할당 해주고, useEffect 내부에서 다시 객체를 만들어 줍니다.</p>
<p>다소 어색한 느낌이 들긴 하지만 useEffect가 의존하는 값을 명시적으로 확인할 수 있고, 부모 컴포넌트의 리렌더링에 따라 useEffect가 호출돼서 connection이 끊길 일도 없습니다.</p>
<pre><code class="language-tsx">function ChatRoom({ options }) {
  const [message, setMessage] = useState('');

  const { roomId, serverUrl } = options;
  useEffect(() => {
    const connection = createConnection({
      roomId: roomId,
      serverUrl: serverUrl
    });
    connection.connect();
    return () => connection.disconnect();
  }, [roomId, serverUrl]);
  // ...
</code></pre>
<h2>마무리</h2>
<p>지금까지 useEffect를 사용하며 놓칠 수 있는 부분과 올바르게 사용할 수 있는 방법에 대해 알아봤습니다.</p>
<p><code>useEffectEvent</code> 훅을 활용하는 방법도 있지만 experimental API라 따로 다루지는 않았습니다.</p>
<p>그래도 대부분의 경우 위에서 설명한 내용들로 대응이 가능할거라 생각합니다.</p>
<p>사실 위에서 작성한 내용은 리액트 <a href="https://react.dev/">공식 문서</a>에 전부 있는 내용입니다.</p>
<p>더욱 자세한 설명이 필요하다면 직접 공식 문서를 정독해보시는 걸 추천드리면서 포스팅을 마칩니다.</p>
<p>봐주셔서 감사합니다.</p>
<h2>참고자료</h2>
<p><a href="https://react.dev/learn/synchronizing-with-effects">synchronizing-with-effects</a></p>
<p><a href="https://react.dev/learn/you-might-not-need-an-effect">you-might-not-need-an-effect</a></p>
<p><a href="https://react.dev/learn/lifecycle-of-reactive-effects">lifecycle-of-reactive-effects</a></p>
<p><a href="https://react.dev/learn/removing-effect-dependencies">removing-effect-dependencies</a></p>
</div></article></main><script src="/_next/static/chunks/webpack-250c8836cd5e2c94.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/css/9b86d158957fd71b.css\",\"style\"]\n0:\"$L2\"\n"])</script><script>self.__next_f.push([1,"3:HL[\"/_next/static/css/f68b3b8746d2b056.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"4:I{\"id\":6054,\"chunks\":[\"272:static/chunks/webpack-250c8836cd5e2c94.js\",\"971:static/chunks/fd9d1056-201df9ae58bf336d.js\",\"864:static/chunks/864-0be03c861a542b53.js\"],\"name\":\"\",\"async\":false}\n6:I{\"id\":1729,\"chunks\":[\"272:static/chunks/webpack-250c8836cd5e2c94.js\",\"971:static/chunks/fd9d1056-201df9ae58bf336d.js\",\"864:static/chunks/864-0be03c861a542b53.js\"],\"name\":\"\",\"async\":false}\n7:I{\"id\":404,\"chunks\":[\"724:static/chunks/724-09e481ac835dbe53.js\",\"185:static/chunks/app/layout-d50ac3a5ad497e37.js\"],\"name\":\"\",\""])</script><script>self.__next_f.push([1,"async\":false}\n8:I{\"id\":1443,\"chunks\":[\"272:static/chunks/webpack-250c8836cd5e2c94.js\",\"971:static/chunks/fd9d1056-201df9ae58bf336d.js\",\"864:static/chunks/864-0be03c861a542b53.js\"],\"name\":\"\",\"async\":false}\n9:I{\"id\":8639,\"chunks\":[\"272:static/chunks/webpack-250c8836cd5e2c94.js\",\"971:static/chunks/fd9d1056-201df9ae58bf336d.js\",\"864:static/chunks/864-0be03c861a542b53.js\"],\"name\":\"\",\"async\":false}\nc:I{\"id\":4244,\"chunks\":[\"724:static/chunks/724-09e481ac835dbe53.js\",\"185:static/chunks/app/layout-d50ac3a5ad497e37.j"])</script><script>self.__next_f.push([1,"s\"],\"name\":\"\",\"async\":false}\n"])</script><script>self.__next_f.push([1,"2:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/9b86d158957fd71b.css\",\"precedence\":\"next\"}]],[\"$\",\"$L4\",null,{\"buildId\":\"n2JQ3oErH7mwUMA1clAxR\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/posts/useEffect\",\"initialTree\":[\"\",{\"children\":[\"posts\",{\"children\":[[\"slug\",\"useEffect\",\"d\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":\\\"useEffect\\\"}\",{}]}]}]},\"$undefined\",\"$undefined\",true],\"initialHead\":[false,\"$L5\"],\"globalErrorComponent\":\"$6\",\"children\":[null,[\"$\",\"html\",null,{\"lang\":\"ko\",\"children\":[\"$\",\"body\",null,{\"children\":[[[\"$\",\"$L7\",null,{}],[\"$\",\"main\",null,{\"className\":\"max-w-screen-md px-5 py-20 m-auto\",\"children\":[\"$\",\"$L8\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"template\":[\"$\",\"$L9\",null,{}],\"templateStyles\":\"$undefined\",\"notFound\":[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":\"404\"}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],\"notFoundStyles\":[],\"childProp\":{\"current\":[\"$\",\"$L8\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"posts\",\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"template\":[\"$\",\"$L9\",null,{}],\"templateStyles\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"childProp\":{\"current\":[\"$\",\"$L8\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"posts\",\"children\",[\"slug\",\"useEffect\",\"d\"],\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"template\":[\"$\",\"$L9\",null,{}],\"templateStyles\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"childProp\":{\"current\":[\"$La\",\"$Lb\",null],\"segment\":\"__PAGE__?{\\\"slug\\\":\\\"useEffect\\\"}\"},\"styles\":[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/f68b3b8746d2b056.css\",\"precedence\":\"next\"}]]}],\"segment\":[\"slug\",\"useEffect\",\"d\"]},\"styles\":[]}],\"segment\":\"posts\"},\"styles\":[]}]}]],[\"$\",\"$Lc\",\"fontawesome\",{\"src\":\"https://kit.fontawesome.com/110e54d917.js\",\"crossOrigin\":\"anonymous\"}],[[\"$\",\"$Lc\",null,{\"strategy\":\"afterInteractive\",\"src\":\"https://www.googletagmanager.com/gtag/js?id=G-RF88KSS1WC\"}],[\"$\",\"$Lc\",null,{\"id\":\"gtag-init\",\"strategy\":\"afterInteractive\",\"dangerouslySetInnerHTML\":{\"__html\":\"\\n                  window.dataLayer = window.dataLayer || [];\\n                  function gtag(){dataLayer.push(arguments);}\\n                  gtag('js', new Date());\\n                  gtag('config', 'G-RF88KSS1WC', {\\n                    page_path: window.location.pathname,\\n                  });\\n                \"}}]]]}]}],null]}]]\n"])</script><script>self.__next_f.push([1,"d:I{\"id\":5992,\"chunks\":[\"719:static/chunks/719-89a63a9863332c2a.js\",\"333:static/chunks/app/posts/[slug]/page-7d9970938d3a476c.js\"],\"name\":\"\",\"async\":false}\ne:T6159,"])</script><script>self.__next_f.push([1,"\u003cp\u003e이번 포스팅에서는 useEffect를 사용하며 놓칠 수 있는 부분과 올바르게 사용하는 방법에 대해 알아보겠습니다.\u003c/p\u003e\n\u003cp\u003e리액트를 사용하는 개발자라면 이미 알고 있는 내용일 수도 있겠지만 다시 한번 정리한다고 생각하고 편하게 봐주시면 좋을 것 같습니다.\u003c/p\u003e\n\u003ch2\u003euseEffect에서 사용하는 모든 값은 반드시 의존성 배열에 포함하기.\u003c/h2\u003e\n\u003cp\u003euseEffect뿐만 아니라 useMemo나 useCallback 등을 사용할 때도 반드시 지켜야 하는 규칙입니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e의존성 배열에 들어가는 값은 선택하는 게 아니고, useEffect에서 사용하는 모든 값을 포함해야 합니다.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e여기서 이야기하는 값은 props, state, 컴포넌트 내부에 정의된 모든 변수와 함수를 의미합니다.\u003c/p\u003e\n\u003cp\u003e왜 위와 같은 규칙을 지켜야 할까요? 간단한 예시를 보여드리겠습니다.\u003c/p\u003e\n\u003cp\u003e버튼으로 increment를 변경하고, 변경된 increment만큼 증가하는 count를 보여주는 Timer 컴포넌트입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-tsx\"\u003eimport { useState, useEffect } from 'react';\n\nexport default function Timer() {\n  const [count, setCount] = useState(0);\n  const [increment, setIncrement] = useState(1);\n\n  function onTick() {\n    setCount(count + increment);\n  }\n\n  useEffect(() =\u003e {\n    const id = setInterval(onTick, 1000);\n    return () =\u003e clearInterval(id);\n  }, []);\n\n  return (\n    \u0026#x3C;\u003e\n      \u0026#x3C;h1\u003e\n        Counter: {count}\n        \u0026#x3C;button onClick={() =\u003e setCount(0)}\u003eReset\u0026#x3C;/button\u003e\n      \u0026#x3C;/h1\u003e\n      \u0026#x3C;hr /\u003e\n      \u0026#x3C;p\u003e\n        Every second, increment by:\n        \u0026#x3C;button disabled={increment === 0} onClick={() =\u003e setIncrement(i =\u003e i - 1)}\u003e\n          –\n        \u0026#x3C;/button\u003e\n        \u0026#x3C;b\u003e{increment}\u0026#x3C;/b\u003e\n        \u0026#x3C;button onClick={() =\u003e setIncrement(i =\u003e i + 1)}\u003e+\u0026#x3C;/button\u003e\n      \u0026#x3C;/p\u003e\n    \u0026#x3C;/\u003e\n  );\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e컴포넌트가 처음 마운트 됐을 때만 타이머를 등록하고 싶다는 생각에 위와 같은 코드를 작성하는 경우가 있습니다.\u003c/p\u003e\n\u003cp\u003euseEffect에서 사용하는 모든 값은 의존성 배열에 포함되어야 한다는 규칙에 어긋난 코드입니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ecount\u003c/code\u003e는 0에서 1로 한번 변경되고 그 이후로 변경되지 않습니다.\u003c/p\u003e\n\u003cp\u003e첫 렌더링시 \u003ccode\u003eonTick\u003c/code\u003e에서 \u003ccode\u003ecount\u003c/code\u003e를 변경할 때 사용되는 \u003ccode\u003ecount\u003c/code\u003e와 \u003ccode\u003eincrement\u003c/code\u003e 값은 각각 \u003ccode\u003euseState\u003c/code\u003e 초갓값인 0과 1입니다.\u003c/p\u003e\n\u003cp\u003euseEffect에서 매초마다 \u003ccode\u003eonTick\u003c/code\u003e를 호출하고 있지만 의존성 배열에는 빈 배열이 전달되고 있기 때문에 \u003ccode\u003eonTick\u003c/code\u003e에서는 매번 \u003ccode\u003esetCount(0 + 1)\u003c/code\u003e을 호출합니다.\u003c/p\u003e\n\u003cp\u003e이와 같은 이유로 \u003ccode\u003ecount\u003c/code\u003e는 1에서 변경되지 않습니다.\u003c/p\u003e\n\u003cp\u003e문제를 해결하기 위해 \u003ccode\u003eonTick\u003c/code\u003e 함수를 의존성 배열에 추가해야 합니다.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://www.npmjs.com/package/eslint-plugin-react-hooks\"\u003eeslint-plugin-react-hooks\u003c/a\u003e를 활용하면 의존성 배열에 필요한 값이 누락될 경우 linter가 경고해 주기 때문에 위와 같은 실수를 방지할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e아래와 같이 linter를 무시하는 주석을 사용하는 경우도 있습니다. 하지만 언제나 linter를 무시하는 방법이 아닌 더 나은 해결책이 있을 겁니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-tsx\"\u003euseEffect(() =\u003e {\n  // eslint-ignore-next-line react-hooks/exhaustive-deps\n}, []);\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003ecleanup function 활용하기.\u003c/h2\u003e\n\u003cp\u003eA 컴포넌트가 처음 마운트 되면 채팅 서버와 커넥션을 맺는다고 가정해 봅시다.\u003c/p\u003e\n\u003cp\u003eA 컴포넌트가 렌더링 되면 useEffect가 호출되고, 채팅 서버와 연결이 됩니다.\u003c/p\u003e\n\u003cp\u003e사용자는 다른 페이지로 이동했다가 다시 A 컴포넌트가 있는 페이지로 이동합니다.\u003c/p\u003e\n\u003cp\u003e다시 useEffect가 호출되면서 다시 연결을 시도하는데 첫 번째 연결은 사라지지 않은 상태로 이루어집니다.\u003c/p\u003e\n\u003cp\u003e이런 동작이 여러 번 반복되면 계속해서 커넥션 연결을 시도하게 되고 버그를 발생시킬 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-tsx\"\u003eexport default function A() {\n  useEffect(() =\u003e {\n    const connection = createConnection();\n    connection.connect();\n  }, []);\n  return \u0026#x3C;h1\u003eWelcome to the chat!\u0026#x3C;/h1\u003e;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이와 같은 문제를 해결하기 위해 cleanup function을 활용할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-tsx\"\u003eexport default function A() {\n  useEffect(() =\u003e {\n    // setup function\n    const connection = createConnection();\n    connection.connect();\n    // cleanup function\n    return () =\u003e {\n      connection.disconnect();\n    };\n  }, []);\n  return \u0026#x3C;h1\u003eWelcome to the chat!\u0026#x3C;/h1\u003e;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ecleanup function은 useEffect가 다시 호출되기 직전, 그리고 컴포넌트가 unmount 될 때 호출됩니다.\u003c/p\u003e\n\u003cp\u003e리액트는 개발 모드일 때 내부적으로 컴포넌트를 remount 시켜서 위와 같은 버그를 예방하도록 합니다.\u003c/p\u003e\n\u003cp\u003e개발 모드일 때 useEffect는 setup =\u003e cleanup =\u003e setup 순서로 호출이 되는데 effect가 두 번 호출되면서 이상하게 동작한다면 잘못된 코드라고 볼 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이를 고치기 위해 코드를 한 번만 호출시키기 위한 방법을 찾기보다는 cleanup function을 활용하여 개발 모드에서도 정상적으로 동작하도록 수정이 되어야 합니다.\u003c/p\u003e\n\u003ch2\u003e불필요한 useEffect 제거하기.\u003c/h2\u003e\n\u003cp\u003e불필요하게 useEffect를 사용하는 경우가 있습니다. 몇 가지 예시를 들어보겠습니다.\u003c/p\u003e\n\u003ch3\u003eprops나 state로 계산이 가능한 경우에는 새로운 state를 만들지 말고, 렌더링 단계에서 계산하기.\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-tsx\"\u003efunction Form() {\n  const [firstName, setFirstName] = useState('Taylor');\n  const [lastName, setLastName] = useState('Swift');\n\n  // fullName이라는 state는 불필요한 state 입니다.\n  const [fullName, setFullName] = useState('');\n  useEffect(() =\u003e {\n    setFullName(firstName + ' ' + lastName);\n  }, [firstName, lastName]);\n\n  // 새로운 state와 effect를 사용하지 말고, 아래와 같은 방식으로 사용 가능합니다.\n  const fullName = firstName + ' ' + lastName;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e아래의 경우에도 마찬가지로 \u003ccode\u003evisibleTodos\u003c/code\u003e라는 state를 새로 만들 필요가 없습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-tsx\"\u003efunction TodoList({ todos, filter }) {\n  const [newTodo, setNewTodo] = useState('');\n\n  const [visibleTodos, setVisibleTodos] = useState([]);\n  useEffect(() =\u003e {\n    setVisibleTodos(getFilteredTodos(todos, filter));\n  }, [todos, filter]);\n\n  // 아래 코드만으로 충분합니다.\n  const visibleTodos = getFilteredTodos(todos, filter);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e만약 \u003ccode\u003egetFilteredTodos\u003c/code\u003e가 오래 걸리는 작업이라면 useMemo로 memoization 할 수 있습니다.\u003cbr\u003e\n\u003ccode\u003etodos\u003c/code\u003e, \u003ccode\u003efilter\u003c/code\u003e의 변경 사항이 없으면 useMemo 내부의 값을 다시 계산하지 않습니다.\u003cbr\u003e\n\u003cstrong\u003e하지만 대부분의 작업은 useMemo가 필요한 만큼 비용이 많이 들지 않습니다.\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-tsx\"\u003eimport { useMemo, useState } from 'react';\n\nfunction TodoList({ todos, filter }) {\n  const [newTodo, setNewTodo] = useState('');\n\n  const visibleTodos = useMemo(() =\u003e {\n    return getFilteredTodos(todos, filter);\n  }, [todos, filter]);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003eprops의 변경에 따라 state를 초기화해야할 경우 key 활용하기.\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eProfilePage\u003c/code\u003e 컴포넌트는 \u003ccode\u003euserId\u003c/code\u003e를 prop으로 받고, \u003ccode\u003ecomment\u003c/code\u003e라는 state를 갖고 있습니다.\n\u003ccode\u003euserId\u003c/code\u003e가 변경됨에 따라 \u003ccode\u003ecomment\u003c/code\u003e를 초기화하기 위해 useEffect를 사용하는 경우가 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-tsx\"\u003eexport default function ProfilePage({ userId }) {\n  const [comment, setComment] = useState('');\n\n  useEffect(() =\u003e {\n    setComment('');\n  }, [userId]);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이때 useEffect 대신에 key를 활용할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e리액트는 동일한 컴포넌트가 동일한 위치에 렌더링 될 때 상태가 유지됩니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003euserId\u003c/code\u003e를 \u003ccode\u003eProfile\u003c/code\u003e 컴포넌트의 key로 전달하면 리액트는 서로 다른 \u003ccode\u003euserId\u003c/code\u003e를 가진 컴포넌트를 각각 다른 컴포넌트로 취급합니다.\u003c/p\u003e\n\u003cp\u003e따라서 key가 변경될 때마다 DOM을 다시 그리고 \u003ccode\u003eProfile\u003c/code\u003e 컴포넌트의 state를 초기화합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-tsx\"\u003eexport default function ProfilePage({ userId }) {\n  return \u0026#x3C;Profile userId={userId} key={userId} /\u003e;\n}\n\nfunction Profile({ userId }) {\n  // comment를 포함하여 Profile 컴포넌트에 정의된 모든 state는 key가 변경되면 초기화 됩니다.\n  const [comment, setComment] = useState('');\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e의존성 제거하기\u003c/h2\u003e\n\u003cp\u003e포스팅 초반에 useEffect에서 사용하는 모든 값은 의존성 배열에 추가해야 한다고 설명했습니다.\u003c/p\u003e\n\u003cp\u003e하지만 여러 가지 값들이 의존성 배열에 담겨있다면 useEffect가 불필요하게 많이 호출되거나 심한 경우 무한 호출이 발생할 수도 있습니다.\u003c/p\u003e\n\u003cp\u003e따라서 필요한 시점에만 useEffect를 호출하기 위해 불필요한 의존성을 줄여야 합니다. 이를 위한 몇 가지 방법을 설명해 드리겠습니다.\u003c/p\u003e\n\u003ch3\u003e이벤트 핸들러로 옮길 수 있는 코드인지 확인.\u003c/h3\u003e\n\u003cp\u003e먼저 useEffect가 정말 필요한 상황이 맞는지 생각해 볼 수 있습니다.\u003c/p\u003e\n\u003cp\u003e아래 예시처럼 \u003ccode\u003esubmitted\u003c/code\u003e라는 state를 두고, 폼을 제출하면 \u003ccode\u003esubmitted\u003c/code\u003e를 변경하고 useEffect에서 \u003ccode\u003esubmitted\u003c/code\u003e에 따라 post 요청을 보내 코드가 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-tsx\"\u003efunction Form() {\n  const [submitted, setSubmitted] = useState(false);\n\n  useEffect(() =\u003e {\n    if (submitted) {\n      post('/api/register');\n      showNotification('Successfully registered!');\n    }\n  }, [submitted]);\n\n  function handleSubmit() {\n    setSubmitted(true);\n  }\n\n  // ...\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e예를 들어 \u003ccode\u003eshowNotification\u003c/code\u003e의 변경 사항으로 \u003ccode\u003etheme\u003c/code\u003e를 받아서 \u003ccode\u003etheme\u003c/code\u003e에 따라 다른 스타일의 notification 메시지를 보여준다고 가정해 봅시다.\u003c/p\u003e\n\u003cp\u003e그럼 \u003ccode\u003eshowNotification\u003c/code\u003e에 \u003ccode\u003etheme\u003c/code\u003e를 인자로 전달해야 하므로 useEffect의 의존성 배열에도 추가해야 합니다.\u003c/p\u003e\n\u003cp\u003e이 경우에는 \u003ccode\u003etheme\u003c/code\u003e만 변경이 되어도 post 요청이 보내지게 됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-tsx\"\u003efunction Form() {\n  const [submitted, setSubmitted] = useState(false);\n  const theme = useContext(ThemeContext);\n\n  useEffect(() =\u003e {\n    if (submitted) {\n      post('/api/register');\n      showNotification('Successfully registered!', theme);\n    }\n  }, [submitted, theme]);\n\n  function handleSubmit() {\n    setSubmitted(true);\n  }\n\n  // ...\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위와 같은 코드는 버그를 만들어 낼 수 있습니다. 따라서 useEffect가 아닌 이벤트 핸들러에서 동작하는 게 더 올바른 코드입니다.\u003c/p\u003e\n\u003cp\u003euseEffect를 사용하기 전에 필요한 상황인지 다시 한번 생각해보세요.\u003c/p\u003e\n\u003cp\u003e특정 인터렉션에 따른 동작일 경우에는 이벤트 핸들러를 활용하는 게 더 나은 방법일 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-tsx\"\u003efunction Form() {\n  const theme = useContext(ThemeContext);\n\n  function handleSubmit() {\n    post('/api/register');\n    showNotification('Successfully registered!', theme);\n  }\n\n  // ...\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003euseEffect 분리하기\u003c/h3\u003e\n\u003cp\u003euseEffect는 목적에 따라 분리해야 합니다.\u003c/p\u003e\n\u003cp\u003e아래 코드는 하나의 useEffect에서 \u003ccode\u003ecities\u003c/code\u003e와 \u003ccode\u003eareas\u003c/code\u003e 데이터를 가져오고 있습니다.\u003c/p\u003e\n\u003cp\u003e특정 상태(country, city) 변화에 따라 관련 없는 API를 호출하게 될 수도 있고, 이는 버그로 이어질 수도 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-tsx\"\u003efunction ShippingForm({ country }) {\n  const [cities, setCities] = useState(null);\n  const [city, setCity] = useState(null);\n  const [areas, setAreas] = useState(null);\n\n  useEffect(() =\u003e {\n    let ignore = false;\n    fetch(`/api/cities?country=${country}`)\n      .then(response =\u003e response.json())\n      .then(json =\u003e {\n        if (!ignore) {\n          setCities(json);\n        }\n      });\n\n    if (city) {\n      fetch(`/api/areas?city=${city}`)\n        .then(response =\u003e response.json())\n        .then(json =\u003e {\n          if (!ignore) {\n            setAreas(json);\n          }\n        });\n    }\n    return () =\u003e {\n      ignore = true;\n    };\n  }, [country, city]);\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이런 경우에는 서로 관련 있는 부분끼리 묶어서 분리할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ecountry\u003c/code\u003e에 의존하는 useEffect와 \u003ccode\u003ecity\u003c/code\u003e에 의존하는 useEffect 두 개로 분리했습니다.\u003c/p\u003e\n\u003cp\u003e목적에 따라 useEffect를 분리하였고, 각각 다른 의존성을 갖고 있어 서로의 코드에 영향을 주지 않습니다.\u003c/p\u003e\n\u003cp\u003e이렇게 함으로써 의도하지 않은 useEffect 호출을 방지할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-tsx\"\u003efunction ShippingForm({ country }) {\n  const [cities, setCities] = useState(null);\n  useEffect(() =\u003e {\n    let ignore = false;\n    fetch(`/api/cities?country=${country}`)\n      .then(response =\u003e response.json())\n      .then(json =\u003e {\n        if (!ignore) {\n          setCities(json);\n        }\n      });\n    return () =\u003e {\n      ignore = true;\n    };\n  }, [country]);\n\n  const [city, setCity] = useState(null);\n  const [areas, setAreas] = useState(null);\n  useEffect(() =\u003e {\n    if (city) {\n      let ignore = false;\n      fetch(`/api/areas?city=${city}`)\n        .then(response =\u003e response.json())\n        .then(json =\u003e {\n          if (!ignore) {\n            setAreas(json);\n          }\n        });\n      return () =\u003e {\n        ignore = true;\n      };\n    }\n  }, [city]);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e코드가 더 길어지긴 했지만, 이전과는 다르게 불필요한 API 호출도 일어나지 않고, 코드를 파악하고, 유지보수하기에도 용이해졌습니다.\u003c/p\u003e\n\u003cp\u003e하나의 useEffect가 한 가지 이상의 목적을 갖고 있다면 분리해 주세요.\u003c/p\u003e\n\u003ch3\u003eupdater function 활용하기.\u003c/h3\u003e\n\u003cp\u003euseEffect에서 상태 변경을 위해 현재 상태를 사용해야 할 경우 \u003ca href=\"https://react.dev/learn/queueing-a-series-of-state-updates\"\u003eupdater function\u003c/a\u003e을 활용할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e아래 코드에서 메시지를 받으면 기존의 \u003ccode\u003emessages\u003c/code\u003e와 새로 받은 메시지를 합쳐 \u003ccode\u003emessage\u003c/code\u003e 상태를 변경합니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003emessages\u003c/code\u003e가 의존성 배열에도 들어가 있고, 문제가 없어 보입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-tsx\"\u003efunction ChatRoom({ roomId }) {\n  const [messages, setMessages] = useState([]);\n  useEffect(() =\u003e {\n    const connection = createConnection();\n    connection.connect();\n    connection.on('message', (receivedMessage) =\u003e {\n      setMessages([...messages, receivedMessage]);\n    });\n    return () =\u003e connection.disconnect();\n  }, [roomId, messages]);\n  // ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위 코드에서 메시지를 받으면 \u003ccode\u003emessages\u003c/code\u003e를 변경하는데 \u003ccode\u003emessages\u003c/code\u003e가 변경되었기 때문에 다시 useEffect를 호출합니다.\u003c/p\u003e\n\u003cp\u003e다시 useEffect를 호출하기 전에 cleanup function 부분이 실행되기 떄문에 \u003ccode\u003econnection\u003c/code\u003e이 끊겼다가 다시 연결됩니다.\u003c/p\u003e\n\u003cp\u003e결국 메시지를 받을 때마다 \u003ccode\u003econnection\u003c/code\u003e이 끊겼다가 다시 연결 시도하는 문제가 발생합니다.\u003c/p\u003e\n\u003cp\u003e이때 updater function을 활용할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003esetMessages\u003c/code\u003e에 updater function을 전달함으로써 의존성 배열에 있는 \u003ccode\u003emessages\u003c/code\u003e를 제거할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이제 \u003ccode\u003emessages\u003c/code\u003e의 변경에 따라 useEffect가 다시 호출되지 않습니다.\u003c/p\u003e\n\u003cp\u003e이처럼 기존의 state를 이용해서 새로운 state를 만들어야 할 경우 updater function을 활용할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-tsx\"\u003efunction ChatRoom({ roomId }) {\n  const [messages, setMessages] = useState([]);\n  useEffect(() =\u003e {\n    const connection = createConnection();\n    connection.connect();\n    connection.on('message', (receivedMessage) =\u003e {\n      setMessages(msgs =\u003e [...msgs, receivedMessage]);\n    });\n    return () =\u003e connection.disconnect();\n  }, [roomId]);\n  // ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e객체나 함수는 컴포넌트 외부나 useEffect 내부에 선언하기.\u003c/h3\u003e\n\u003cp\u003e가능하면 객체나 함수는 의존성 배열에 포함하지 않는 것이 좋습니다.\u003c/p\u003e\n\u003cp\u003e그 이유는 컴포넌트 내부에 있는 객체나 함수는 렌더링마다 새로 생성되기 때문입니다.\u003c/p\u003e\n\u003cp\u003e이로인해 의도치 않은 useEffect 호출이 여러 번 발생할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e아래 ChatRoom 컴포넌트는 다음과 같이 동작합니다.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003einput이 변경될 때마다 컴포넌트 리렌더링.\u003c/li\u003e\n\u003cli\u003e렌더링마다 \u003ccode\u003eoptions\u003c/code\u003e 새로 생성.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eoptions\u003c/code\u003e의 변경에 따라 useEffect 호출.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e결국 input의 변경이 매번 connection을 다시 만드는 잘못된 동작을 만들어 내고 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-tsx\"\u003econst serverUrl = 'https://localhost:1234';\n\nfunction ChatRoom({ roomId }) {\n  const [message, setMessage] = useState('');\n\n  const options = {\n    serverUrl: serverUrl,\n    roomId: roomId,\n  };\n\n  useEffect(() =\u003e {\n    const connection = createConnection(options);\n    connection.connect();\n    return () =\u003e connection.disconnect();\n  }, [options]);\n\n  return (\n    \u0026#x3C;\u003e\n      \u0026#x3C;h1\u003eWelcome to the {roomId} room!\u0026#x3C;/h1\u003e\n      \u0026#x3C;input value={message} onChange={e =\u003e setMessage(e.target.value)} /\u003e\n    \u0026#x3C;/\u003e\n  );\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003e정적인 객체나 함수는 컴포넌트 외부에 선언.\u003c/h4\u003e\n\u003cp\u003e이를 막기 위해 정적인 객체나 함수는 컴포넌트 외부에 선언하여 의존성을 제거할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e만약 \u003ccode\u003eoptions\u003c/code\u003e가 정적인 객체라면 컴포넌트 외부에 선언하면 됩니다.\u003c/p\u003e\n\u003cp\u003e컴포넌트 외부에 선언하면 \u003ccode\u003eoptions\u003c/code\u003e는 리렌더링에 따라 변하지 않는 값이기 때문에 의존성 배열에서 제거할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-tsx\"\u003econst options = {\n  serverUrl: 'https://localhost:1234',\n  roomId: 'music'\n};\n\nfunction ChatRoom() {\n  const [message, setMessage] = useState('');\n\n  useEffect(() =\u003e {\n    const connection = createConnection(options);\n    connection.connect();\n    return () =\u003e connection.disconnect();\n  }, []);\n  // ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e함수일 경우에도 마찬가지입니다.\u003c/p\u003e\n\u003cp\u003e컴포넌트에 의존하는 값이 없으면 함수를 컴포넌트 외부에 선언하면 의존성 배열에 추가할 필요가 없습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-tsx\"\u003efunction createOptions() {\n  return {\n    serverUrl: 'https://localhost:1234',\n    roomId: 'music'\n  };\n}\n\nfunction ChatRoom() {\n  const [message, setMessage] = useState('');\n\n  useEffect(() =\u003e {\n    const options = createOptions();\n    const connection = createConnection();\n    connection.connect();\n    return () =\u003e connection.disconnect();\n  }, []);\n  // ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003e동적인 객체나 함수는 useEffect 내부에 선언.\u003c/h4\u003e\n\u003cp\u003eprops나 state 등 동적인 값에 의존하는 객체나 함수는 useEffect 내부에 선언하여 의존성을 제거할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e기존 예시에서는 \u003ccode\u003eroomId\u003c/code\u003e를 prop으로 전달받고, \u003ccode\u003eoptions\u003c/code\u003e는 \u003ccode\u003eroomId\u003c/code\u003e에 의존하고 있었습니다.\u003c/p\u003e\n\u003cp\u003e이런 경우에는 \u003ccode\u003eoptions\u003c/code\u003e를 \u003ccode\u003euseEffect\u003c/code\u003e 내부로 옮기면 됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-tsx\"\u003econst serverUrl = 'https://localhost:1234';\n\nfunction ChatRoom({ roomId }) {\n  const [message, setMessage] = useState('');\n\n  useEffect(() =\u003e {\n    const options = {\n      serverUrl: serverUrl,\n      roomId: roomId\n    };\n    const connection = createConnection(options);\n    connection.connect();\n    return () =\u003e connection.disconnect();\n  }, [roomId]);\n  // ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eoptions\u003c/code\u003e는 useEffect 내부로 옮겼고, \u003ccode\u003eroomId\u003c/code\u003e를 사용하고 있기 때문에 의존성 배열에 roomId만 추가해 주면 됩니다.\u003c/p\u003e\n\u003cp\u003e코드에 \u003ccode\u003eroomId\u003c/code\u003e의 타입은 나와 있지 않지만 primitive 타입이라고 가정합니다.\u003c/p\u003e\n\u003cp\u003e이제 useEffect가 \u003ccode\u003eoptions\u003c/code\u003e 객체가 아닌 \u003ccode\u003eroomId\u003c/code\u003e에만 의존하고 있기 때문에 이전처럼 \u003ccode\u003emessage\u003c/code\u003e 변경에 따라 useEffect가 호출되지 않습니다.\u003c/p\u003e\n\u003cp\u003e함수일 경우에도 마찬가지로 useEffect 내부에 선언해 줘서 의존성을 줄이고 불필요한 useEffect 호출을 막을 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-tsx\"\u003econst serverUrl = 'https://localhost:1234';\n\nfunction ChatRoom({ roomId }) {\n  const [message, setMessage] = useState('');\n\n  useEffect(() =\u003e {\n    function createOptions() {\n      return {\n        serverUrl: serverUrl,\n        roomId: roomId\n      };\n    }\n\n    const options = createOptions();\n    const connection = createConnection(options);\n    connection.connect();\n    return () =\u003e connection.disconnect();\n  }, [roomId]);\n  // ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e다시 한번 정리하자면 useEffect에서 사용되는 객체나 함수는 정적인 값일 경우에는 컴포넌트 외부로 옮기고, 동적인 값일 경우에는 useEffect 내부로 옮겨서 의존성을 없애고, 불필요한 호출을 막을 수 있습니다.\u003c/p\u003e\n\u003cp\u003e가능하면 객체나 함수가 의존성 배열에 포함되지 않도록 해주세요.\u003c/p\u003e\n\u003ch4\u003e객체나 함수를 props로 전달받는 경우\u003c/h4\u003e\n\u003cp\u003e물론 useEffect 에서 객체나 함수를 전달받아 사용해야 하는 경우도 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eChatRoom\u003c/code\u003e 컴포넌트는 부모 컴포넌트로부터 \u003ccode\u003eoptions\u003c/code\u003e를 props로 받고 있습니다.\u003c/p\u003e\n\u003cp\u003e이 경우에는 \u003ccode\u003eChatRoom\u003c/code\u003e의 부모 컴포넌트가 리렌더링 될 때마다 \u003ccode\u003eChatRoom\u003c/code\u003e의 useEffect도 다시 호출됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-tsx\"\u003efunction ChatRoom({ options }) {\n  const [message, setMessage] = useState('');\n\n  useEffect(() =\u003e {\n    const connection = createConnection(options);\n    connection.connect();\n    return () =\u003e connection.disconnect();\n  }, [options]);\n  // ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"language-tsx\"\u003e\u0026#x3C;ChatRoom\n  roomId={roomId}\n  options={{\n    serverUrl: serverUrl,\n    roomId: roomId,\n  }}\n/\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위의 경우에는 아래 코드처럼 useEffect 외부에서 \u003ccode\u003eoptions\u003c/code\u003e를 구조 분해 할당 해주고, useEffect 내부에서 다시 객체를 만들어 줍니다.\u003c/p\u003e\n\u003cp\u003e다소 어색한 느낌이 들긴 하지만 useEffect가 의존하는 값을 명시적으로 확인할 수 있고, 부모 컴포넌트의 리렌더링에 따라 useEffect가 호출돼서 connection이 끊길 일도 없습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-tsx\"\u003efunction ChatRoom({ options }) {\n  const [message, setMessage] = useState('');\n\n  const { roomId, serverUrl } = options;\n  useEffect(() =\u003e {\n    const connection = createConnection({\n      roomId: roomId,\n      serverUrl: serverUrl\n    });\n    connection.connect();\n    return () =\u003e connection.disconnect();\n  }, [roomId, serverUrl]);\n  // ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e마무리\u003c/h2\u003e\n\u003cp\u003e지금까지 useEffect를 사용하며 놓칠 수 있는 부분과 올바르게 사용할 수 있는 방법에 대해 알아봤습니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003euseEffectEvent\u003c/code\u003e 훅을 활용하는 방법도 있지만 experimental API라 따로 다루지는 않았습니다.\u003c/p\u003e\n\u003cp\u003e그래도 대부분의 경우 위에서 설명한 내용들로 대응이 가능할거라 생각합니다.\u003c/p\u003e\n\u003cp\u003e사실 위에서 작성한 내용은 리액트 \u003ca href=\"https://react.dev/\"\u003e공식 문서\u003c/a\u003e에 전부 있는 내용입니다.\u003c/p\u003e\n\u003cp\u003e더욱 자세한 설명이 필요하다면 직접 공식 문서를 정독해보시는 걸 추천드리면서 포스팅을 마칩니다.\u003c/p\u003e\n\u003cp\u003e봐주셔서 감사합니다.\u003c/p\u003e\n\u003ch2\u003e참고자료\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://react.dev/learn/synchronizing-with-effects\"\u003esynchronizing-with-effects\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://react.dev/learn/you-might-not-need-an-effect\"\u003eyou-might-not-need-an-effect\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://react.dev/learn/lifecycle-of-reactive-effects\"\u003elifecycle-of-reactive-effects\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://react.dev/learn/removing-effect-dependencies\"\u003eremoving-effect-dependencies\u003c/a\u003e\u003c/p\u003e\n"])</script><script>self.__next_f.push([1,"b:[\"$\",\"article\",null,{\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-3xl font-extrabold\",\"children\":\"useEffect 제대로 사용하기\"}],[\"$\",\"time\",null,{\"className\":\"text-gray-500 font-extralight\",\"dateTime\":\"2023-10-05\",\"children\":\"2023 October 5\"}],[\"$\",\"$Ld\",null,{\"content\":\"$e\"}]]}]\n"])</script><script>self.__next_f.push([1,"5:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"1\",{\"children\":\"useEffect 제대로 사용하기 - oungo\"}],[\"$\",\"meta\",\"2\",{\"name\":\"description\",\"content\":\"이번 포스팅에서는 useEffect를 사용하며 놓칠 수 있는 부분과 올바르게 사용하는 방법에 대해 알아보겠습니다.\"}],[\"$\",\"meta\",\"3\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"4\",{\"property\":\"og:title\",\"content\":\"useEffect 제대로 사용하기\"}],[\"$\",\"meta\",\"5\",{\"property\":\"og:description\",\"content\":\"이번 포스팅에서는 useEffect를 사용하며 놓칠 수 있는 부분과 올바르게 사용하는 방법에 대해 알아보겠습니다.\"}],[\"$\",\"meta\",\"6\",{\"property\":\"og:url\",\"content\":\"https://oungo.github.io/posts/useEffect\"}],[\"$\",\"meta\",\"7\",{\"property\":\"og:image\",\"content\":\"https://oungo.github.io/og-image.svg\"}],[\"$\",\"meta\",\"8\",{\"property\":\"og:image:width\",\"content\":\"1200\"}],[\"$\",\"meta\",\"9\",{\"property\":\"og:image:height\",\"content\":\"630\"}],[\"$\",\"meta\",\"10\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"11\",{\"name\":\"twitter:title\",\"content\":\"useEffect 제대로 사용하기\"}],[\"$\",\"meta\",\"12\",{\"name\":\"twitter:description\",\"content\":\"이번 포스팅에서는 useEffect를 사용하며 놓칠 수 있는 부분과 올바르게 사용하는 방법에 대해 알아보겠습니다.\"}],[\"$\",\"meta\",\"13\",{\"name\":\"twitter:image\",\"content\":\"https://oungo.github.io/og-image.svg\"}],[\"$\",\"link\",\"14\",{\"rel\":\"icon\",\"href\":\"/favicon.ico\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}],[\"$\",\"link\",\"15\",{\"rel\":\"icon\",\"href\":\"/icon1.png?8fb7eecf67fe01e8\",\"type\":\"image/png\",\"sizes\":\"16x16\"}],[\"$\",\"link\",\"16\",{\"rel\":\"icon\",\"href\":\"/icon2.png?e043058d2ad29a8c\",\"type\":\"image/png\",\"sizes\":\"32x32\"}],[\"$\",\"link\",\"17\",{\"rel\":\"apple-touch-icon\",\"href\":\"/apple-icon.png?f59fae947b3e763d\",\"type\":\"image/png\",\"sizes\":\"180x180\"}]]\n"])</script><script>self.__next_f.push([1,"a:null\n"])</script></body></html>