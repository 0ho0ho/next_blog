"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/markdown-table";
exports.ids = ["vendor-chunks/markdown-table"];
exports.modules = {

/***/ "(rsc)/./node_modules/markdown-table/index.js":
/*!**********************************************!*\
  !*** ./node_modules/markdown-table/index.js ***!
  \**********************************************/
/***/ ((module) => {

eval("\nmodule.exports = markdownTable;\nvar dotRe = /\\./;\nvar lastDotRe = /\\.[^.]*$/;\n// Characters.\nvar space = \" \";\nvar lineFeed = \"\\n\";\nvar dash = \"-\";\nvar dot = \".\";\nvar colon = \":\";\nvar lowercaseC = \"c\";\nvar lowercaseL = \"l\";\nvar lowercaseR = \"r\";\nvar verticalBar = \"|\";\nvar minCellSize = 3;\n// Create a table from a matrix of strings.\nfunction markdownTable(table, options) {\n    var settings = options || {};\n    var delimiter = settings.delimiter;\n    var start = settings.start;\n    var end = settings.end;\n    var alignment = settings.align;\n    var calculateStringLength = settings.stringLength || lengthNoop;\n    var cellCount = 0;\n    var rowIndex = -1;\n    var rowLength = table.length;\n    var sizes = [];\n    var align;\n    var rule;\n    var rows;\n    var row;\n    var cells;\n    var index;\n    var position;\n    var size;\n    var value;\n    var spacing;\n    var before;\n    var after;\n    alignment = alignment ? alignment.concat() : [];\n    if (delimiter === null || delimiter === undefined) {\n        delimiter = space + verticalBar + space;\n    }\n    if (start === null || start === undefined) {\n        start = verticalBar + space;\n    }\n    if (end === null || end === undefined) {\n        end = space + verticalBar;\n    }\n    while(++rowIndex < rowLength){\n        row = table[rowIndex];\n        index = -1;\n        if (row.length > cellCount) {\n            cellCount = row.length;\n        }\n        while(++index < cellCount){\n            position = row[index] ? dotindex(row[index]) : null;\n            if (!sizes[index]) {\n                sizes[index] = minCellSize;\n            }\n            if (position > sizes[index]) {\n                sizes[index] = position;\n            }\n        }\n    }\n    if (typeof alignment === \"string\") {\n        alignment = pad(cellCount, alignment).split(\"\");\n    }\n    // Make sure only valid alignments are used.\n    index = -1;\n    while(++index < cellCount){\n        align = alignment[index];\n        if (typeof align === \"string\") {\n            align = align.charAt(0).toLowerCase();\n        }\n        if (align !== lowercaseL && align !== lowercaseR && align !== lowercaseC && align !== dot) {\n            align = \"\";\n        }\n        alignment[index] = align;\n    }\n    rowIndex = -1;\n    rows = [];\n    while(++rowIndex < rowLength){\n        row = table[rowIndex];\n        index = -1;\n        cells = [];\n        while(++index < cellCount){\n            value = row[index];\n            value = stringify(value);\n            if (alignment[index] === dot) {\n                position = dotindex(value);\n                size = sizes[index] + (dotRe.test(value) ? 0 : 1) - (calculateStringLength(value) - position);\n                cells[index] = value + pad(size - 1);\n            } else {\n                cells[index] = value;\n            }\n        }\n        rows[rowIndex] = cells;\n    }\n    sizes = [];\n    rowIndex = -1;\n    while(++rowIndex < rowLength){\n        cells = rows[rowIndex];\n        index = -1;\n        while(++index < cellCount){\n            value = cells[index];\n            if (!sizes[index]) {\n                sizes[index] = minCellSize;\n            }\n            size = calculateStringLength(value);\n            if (size > sizes[index]) {\n                sizes[index] = size;\n            }\n        }\n    }\n    rowIndex = -1;\n    while(++rowIndex < rowLength){\n        cells = rows[rowIndex];\n        index = -1;\n        if (settings.pad !== false) {\n            while(++index < cellCount){\n                value = cells[index];\n                position = sizes[index] - (calculateStringLength(value) || 0);\n                spacing = pad(position);\n                if (alignment[index] === lowercaseR || alignment[index] === dot) {\n                    value = spacing + value;\n                } else if (alignment[index] === lowercaseC) {\n                    position /= 2;\n                    if (position % 1 === 0) {\n                        before = position;\n                        after = position;\n                    } else {\n                        before = position + 0.5;\n                        after = position - 0.5;\n                    }\n                    value = pad(before) + value + pad(after);\n                } else {\n                    value += spacing;\n                }\n                cells[index] = value;\n            }\n        }\n        rows[rowIndex] = cells.join(delimiter);\n    }\n    if (settings.rule !== false) {\n        index = -1;\n        rule = [];\n        while(++index < cellCount){\n            // When `pad` is false, make the rule the same size as the first row.\n            if (settings.pad === false) {\n                value = table[0][index];\n                spacing = calculateStringLength(stringify(value));\n                spacing = spacing > minCellSize ? spacing : minCellSize;\n            } else {\n                spacing = sizes[index];\n            }\n            align = alignment[index];\n            // When `align` is left, don't add colons.\n            value = align === lowercaseR || align === \"\" ? dash : colon;\n            value += pad(spacing - 2, dash);\n            value += align !== lowercaseL && align !== \"\" ? colon : dash;\n            rule[index] = value;\n        }\n        rows.splice(1, 0, rule.join(delimiter));\n    }\n    return start + rows.join(end + lineFeed + start) + end;\n}\nfunction stringify(value) {\n    return value === null || value === undefined ? \"\" : String(value);\n}\n// Get the length of `value`.\nfunction lengthNoop(value) {\n    return String(value).length;\n}\n// Get a string consisting of `length` `character`s.\nfunction pad(length, character) {\n    return new Array(length + 1).join(character || space);\n}\n// Get the position of the last dot in `value`.\nfunction dotindex(value) {\n    var match = lastDotRe.exec(value);\n    return match ? match.index + 1 : value.length;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbWFya2Rvd24tdGFibGUvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQUEsT0FBT0MsT0FBTyxHQUFHQztBQUVqQixJQUFJQyxRQUFRO0FBQ1osSUFBSUMsWUFBWTtBQUVoQixjQUFjO0FBQ2QsSUFBSUMsUUFBUTtBQUNaLElBQUlDLFdBQVc7QUFDZixJQUFJQyxPQUFPO0FBQ1gsSUFBSUMsTUFBTTtBQUNWLElBQUlDLFFBQVE7QUFDWixJQUFJQyxhQUFhO0FBQ2pCLElBQUlDLGFBQWE7QUFDakIsSUFBSUMsYUFBYTtBQUNqQixJQUFJQyxjQUFjO0FBRWxCLElBQUlDLGNBQWM7QUFFbEIsMkNBQTJDO0FBQzNDLFNBQVNaLGNBQWNhLEtBQUssRUFBRUMsT0FBTztJQUNuQyxJQUFJQyxXQUFXRCxXQUFXLENBQUM7SUFDM0IsSUFBSUUsWUFBWUQsU0FBU0MsU0FBUztJQUNsQyxJQUFJQyxRQUFRRixTQUFTRSxLQUFLO0lBQzFCLElBQUlDLE1BQU1ILFNBQVNHLEdBQUc7SUFDdEIsSUFBSUMsWUFBWUosU0FBU0ssS0FBSztJQUM5QixJQUFJQyx3QkFBd0JOLFNBQVNPLFlBQVksSUFBSUM7SUFDckQsSUFBSUMsWUFBWTtJQUNoQixJQUFJQyxXQUFXLENBQUM7SUFDaEIsSUFBSUMsWUFBWWIsTUFBTWMsTUFBTTtJQUM1QixJQUFJQyxRQUFRLEVBQUU7SUFDZCxJQUFJUjtJQUNKLElBQUlTO0lBQ0osSUFBSUM7SUFDSixJQUFJQztJQUNKLElBQUlDO0lBQ0osSUFBSUM7SUFDSixJQUFJQztJQUNKLElBQUlDO0lBQ0osSUFBSUM7SUFDSixJQUFJQztJQUNKLElBQUlDO0lBQ0osSUFBSUM7SUFFSnBCLFlBQVlBLFlBQVlBLFVBQVVxQixNQUFNLEtBQUssRUFBRTtJQUUvQyxJQUFJeEIsY0FBYyxRQUFRQSxjQUFjeUIsV0FBVztRQUNqRHpCLFlBQVliLFFBQVFRLGNBQWNSO0lBQ3BDO0lBRUEsSUFBSWMsVUFBVSxRQUFRQSxVQUFV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VSxLQUFLZixPQUFPRTtZQUN0RDZCLFNBQVNPLElBQUlOLFVBQVUsR0FBR2hDO1lBQzFCK0IsU0FBU2hCLFVBQVVYLGNBQWNXLFVBQVUsS0FBS2IsUUFBUUY7WUFFeER3QixJQUFJLENBQUNJLE1BQU0sR0FBR0c7UUFDaEI7UUFFQU4sS0FBS29CLE1BQU0sQ0FBQyxHQUFHLEdBQUdyQixLQUFLb0IsSUFBSSxDQUFDakM7SUFDOUI7SUFFQSxPQUFPQyxRQUFRYSxLQUFLbUIsSUFBSSxDQUFDL0IsTUFBTWQsV0FBV2EsU0FBU0M7QUFDckQ7QUFFQSxTQUFTNkIsVUFBVVgsS0FBSztJQUN0QixPQUFPQSxVQUFVLFFBQVFBLFVBQVVLLFlBQVksS0FBS1UsT0FBT2Y7QUFDN0Q7QUFFQSw2QkFBNkI7QUFDN0IsU0FBU2IsV0FBV2EsS0FBSztJQUN2QixPQUFPZSxPQUFPZixPQUFPVCxNQUFNO0FBQzdCO0FBRUEsb0RBQW9EO0FBQ3BELFNBQVNnQixJQUFJaEIsTUFBTSxFQUFFeUIsU0FBUztJQUM1QixPQUFPLElBQUlDLE1BQU0xQixTQUFTLEdBQUdzQixJQUFJLENBQUNHLGFBQWFqRDtBQUNqRDtBQUVBLCtDQUErQztBQUMvQyxTQUFTdUMsU0FBU04sS0FBSztJQUNyQixJQUFJa0IsUUFBUXBELFVBQVVxRCxJQUFJLENBQUNuQjtJQUUzQixPQUFPa0IsUUFBUUEsTUFBTXJCLEtBQUssR0FBRyxJQUFJRyxNQUFNVCxNQUFNO0FBQy9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYmxvZy1zdGFydGVyLXR5cGVzY3JpcHQvLi9ub2RlX21vZHVsZXMvbWFya2Rvd24tdGFibGUvaW5kZXguanM/OTVjZCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMgPSBtYXJrZG93blRhYmxlXG5cbnZhciBkb3RSZSA9IC9cXC4vXG52YXIgbGFzdERvdFJlID0gL1xcLlteLl0qJC9cblxuLy8gQ2hhcmFjdGVycy5cbnZhciBzcGFjZSA9ICcgJ1xudmFyIGxpbmVGZWVkID0gJ1xcbidcbnZhciBkYXNoID0gJy0nXG52YXIgZG90ID0gJy4nXG52YXIgY29sb24gPSAnOidcbnZhciBsb3dlcmNhc2VDID0gJ2MnXG52YXIgbG93ZXJjYXNlTCA9ICdsJ1xudmFyIGxvd2VyY2FzZVIgPSAncidcbnZhciB2ZXJ0aWNhbEJhciA9ICd8J1xuXG52YXIgbWluQ2VsbFNpemUgPSAzXG5cbi8vIENyZWF0ZSBhIHRhYmxlIGZyb20gYSBtYXRyaXggb2Ygc3RyaW5ncy5cbmZ1bmN0aW9uIG1hcmtkb3duVGFibGUodGFibGUsIG9wdGlvbnMpIHtcbiAgdmFyIHNldHRpbmdzID0gb3B0aW9ucyB8fCB7fVxuICB2YXIgZGVsaW1pdGVyID0gc2V0dGluZ3MuZGVsaW1pdGVyXG4gIHZhciBzdGFydCA9IHNldHRpbmdzLnN0YXJ0XG4gIHZhciBlbmQgPSBzZXR0aW5ncy5lbmRcbiAgdmFyIGFsaWdubWVudCA9IHNldHRpbmdzLmFsaWduXG4gIHZhciBjYWxjdWxhdGVTdHJpbmdMZW5ndGggPSBzZXR0aW5ncy5zdHJpbmdMZW5ndGggfHwgbGVuZ3RoTm9vcFxuICB2YXIgY2VsbENvdW50ID0gMFxuICB2YXIgcm93SW5kZXggPSAtMVxuICB2YXIgcm93TGVuZ3RoID0gdGFibGUubGVuZ3RoXG4gIHZhciBzaXplcyA9IFtdXG4gIHZhciBhbGlnblxuICB2YXIgcnVsZVxuICB2YXIgcm93c1xuICB2YXIgcm93XG4gIHZhciBjZWxsc1xuICB2YXIgaW5kZXhcbiAgdmFyIHBvc2l0aW9uXG4gIHZhciBzaXplXG4gIHZhciB2YWx1ZVxuICB2YXIgc3BhY2luZ1xuICB2YXIgYmVmb3JlXG4gIHZhciBhZnRlclxuXG4gIGFsaWdubWVudCA9IGFsaWdubWVudCA/IGFsaWdubWVudC5jb25jYXQoKSA6IFtdXG5cbiAgaWYgKGRlbGltaXRlciA9PT0gbnVsbCB8fCBkZWxpbWl0ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgIGRlbGltaXRlciA9IHNwYWNlICsgdmVydGljYWxCYXIgKyBzcGFjZVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSBudWxsIHx8IHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICBzdGFydCA9IHZlcnRpY2FsQmFyICsgc3BhY2VcbiAgfVxuXG4gIGlmIChlbmQgPT09IG51bGwgfHwgZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmQgPSBzcGFjZSArIHZlcnRpY2FsQmFyXG4gIH1cblxuICB3aGlsZSAoKytyb3dJbmRleCA8IHJvd0xlbmd0aCkge1xuICAgIHJvdyA9IHRhYmxlW3Jvd0luZGV4XVxuXG4gICAgaW5kZXggPSAtMVxuXG4gICAgaWYgKHJvdy5sZW5ndGggPiBjZWxsQ291bnQpIHtcbiAgICAgIGNlbGxDb3VudCA9IHJvdy5sZW5ndGhcbiAgICB9XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGNlbGxDb3VudCkge1xuICAgICAgcG9zaXRpb24gPSByb3dbaW5kZXhdID8gZG90aW5kZXgocm93W2luZGV4XSkgOiBudWxsXG5cbiAgICAgIGlmICghc2l6ZXNbaW5kZXhdKSB7XG4gICAgICAgIHNpemVzW2luZGV4XSA9IG1pbkNlbGxTaXplXG4gICAgICB9XG5cbiAgICAgIGlmIChwb3NpdGlvbiA+IHNpemVzW2luZGV4XSkge1xuICAgICAgICBzaXplc1tpbmRleF0gPSBwb3NpdGlvblxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgYWxpZ25tZW50ID09PSAnc3RyaW5nJykge1xuICAgIGFsaWdubWVudCA9IHBhZChjZWxsQ291bnQsIGFsaWdubWVudCkuc3BsaXQoJycpXG4gIH1cblxuICAvLyBNYWtlIHN1cmUgb25seSB2YWxpZCBhbGlnbm1lbnRzIGFyZSB1c2VkLlxuICBpbmRleCA9IC0xXG5cbiAgd2hpbGUgKCsraW5kZXggPCBjZWxsQ291bnQpIHtcbiAgICBhbGlnbiA9IGFsaWdubWVudFtpbmRleF1cblxuICAgIGlmICh0eXBlb2YgYWxpZ24gPT09ICdzdHJpbmcnKSB7XG4gICAgICBhbGlnbiA9IGFsaWduLmNoYXJBdCgwKS50b0xvd2VyQ2FzZSgpXG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgYWxpZ24gIT09IGxvd2VyY2FzZUwgJiZcbiAgICAgIGFsaWduICE9PSBsb3dlcmNhc2VSICYmXG4gICAgICBhbGlnbiAhPT0gbG93ZXJjYXNlQyAmJlxuICAgICAgYWxpZ24gIT09IGRvdFxuICAgICkge1xuICAgICAgYWxpZ24gPSAnJ1xuICAgIH1cblxuICAgIGFsaWdubWVudFtpbmRleF0gPSBhbGlnblxuICB9XG5cbiAgcm93SW5kZXggPSAtMVxuICByb3dzID0gW11cblxuICB3aGlsZSAoKytyb3dJbmRleCA8IHJvd0xlbmd0aCkge1xuICAgIHJvdyA9IHRhYmxlW3Jvd0luZGV4XVxuXG4gICAgaW5kZXggPSAtMVxuICAgIGNlbGxzID0gW11cblxuICAgIHdoaWxlICgrK2luZGV4IDwgY2VsbENvdW50KSB7XG4gICAgICB2YWx1ZSA9IHJvd1tpbmRleF1cblxuICAgICAgdmFsdWUgPSBzdHJpbmdpZnkodmFsdWUpXG5cbiAgICAgIGlmIChhbGlnbm1lbnRbaW5kZXhdID09PSBkb3QpIHtcbiAgICAgICAgcG9zaXRpb24gPSBkb3RpbmRleCh2YWx1ZSlcblxuICAgICAgICBzaXplID1cbiAgICAgICAgICBzaXplc1tpbmRleF0gK1xuICAgICAgICAgIChkb3RSZS50ZXN0KHZhbHVlKSA/IDAgOiAxKSAtXG4gICAgICAgICAgKGNhbGN1bGF0ZVN0cmluZ0xlbmd0aCh2YWx1ZSkgLSBwb3NpdGlvbilcblxuICAgICAgICBjZWxsc1tpbmRleF0gPSB2YWx1ZSArIHBhZChzaXplIC0gMSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNlbGxzW2luZGV4XSA9IHZhbHVlXG4gICAgICB9XG4gICAgfVxuXG4gICAgcm93c1tyb3dJbmRleF0gPSBjZWxsc1xuICB9XG5cbiAgc2l6ZXMgPSBbXVxuICByb3dJbmRleCA9IC0xXG5cbiAgd2hpbGUgKCsrcm93SW5kZXggPCByb3dMZW5ndGgpIHtcbiAgICBjZWxscyA9IHJvd3Nbcm93SW5kZXhdXG5cbiAgICBpbmRleCA9IC0xXG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGNlbGxDb3VudCkge1xuICAgICAgdmFsdWUgPSBjZWxsc1tpbmRleF1cblxuICAgICAgaWYgKCFzaXplc1tpbmRleF0pIHtcbiAgICAgICAgc2l6ZXNbaW5kZXhdID0gbWluQ2VsbFNpemVcbiAgICAgIH1cblxuICAgICAgc2l6ZSA9IGNhbGN1bGF0ZVN0cmluZ0xlbmd0aCh2YWx1ZSlcblxuICAgICAgaWYgKHNpemUgPiBzaXplc1tpbmRleF0pIHtcbiAgICAgICAgc2l6ZXNbaW5kZXhdID0gc2l6ZVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJvd0luZGV4ID0gLTFcblxuICB3aGlsZSAoKytyb3dJbmRleCA8IHJvd0xlbmd0aCkge1xuICAgIGNlbGxzID0gcm93c1tyb3dJbmRleF1cblxuICAgIGluZGV4ID0gLTFcblxuICAgIGlmIChzZXR0aW5ncy5wYWQgIT09IGZhbHNlKSB7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGNlbGxDb3VudCkge1xuICAgICAgICB2YWx1ZSA9IGNlbGxzW2luZGV4XVxuXG4gICAgICAgIHBvc2l0aW9uID0gc2l6ZXNbaW5kZXhdIC0gKGNhbGN1bGF0ZVN0cmluZ0xlbmd0aCh2YWx1ZSkgfHwgMClcbiAgICAgICAgc3BhY2luZyA9IHBhZChwb3NpdGlvbilcblxuICAgICAgICBpZiAoYWxpZ25tZW50W2luZGV4XSA9PT0gbG93ZXJjYXNlUiB8fCBhbGlnbm1lbnRbaW5kZXhdID09PSBkb3QpIHtcbiAgICAgICAgICB2YWx1ZSA9IHNwYWNpbmcgKyB2YWx1ZVxuICAgICAgICB9IGVsc2UgaWYgKGFsaWdubWVudFtpbmRleF0gPT09IGxvd2VyY2FzZUMpIHtcbiAgICAgICAgICBwb3NpdGlvbiAvPSAyXG5cbiAgICAgICAgICBpZiAocG9zaXRpb24gJSAxID09PSAwKSB7XG4gICAgICAgICAgICBiZWZvcmUgPSBwb3NpdGlvblxuICAgICAgICAgICAgYWZ0ZXIgPSBwb3NpdGlvblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBiZWZvcmUgPSBwb3NpdGlvbiArIDAuNVxuICAgICAgICAgICAgYWZ0ZXIgPSBwb3NpdGlvbiAtIDAuNVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhbHVlID0gcGFkKGJlZm9yZSkgKyB2YWx1ZSArIHBhZChhZnRlcilcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSArPSBzcGFjaW5nXG4gICAgICAgIH1cblxuICAgICAgICBjZWxsc1tpbmRleF0gPSB2YWx1ZVxuICAgICAgfVxuICAgIH1cblxuICAgIHJvd3Nbcm93SW5kZXhdID0gY2VsbHMuam9pbihkZWxpbWl0ZXIpXG4gIH1cblxuICBpZiAoc2V0dGluZ3MucnVsZSAhPT0gZmFsc2UpIHtcbiAgICBpbmRleCA9IC0xXG4gICAgcnVsZSA9IFtdXG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGNlbGxDb3VudCkge1xuICAgICAgLy8gV2hlbiBgcGFkYCBpcyBmYWxzZSwgbWFrZSB0aGUgcnVsZSB0aGUgc2FtZSBzaXplIGFzIHRoZSBmaXJzdCByb3cuXG4gICAgICBpZiAoc2V0dGluZ3MucGFkID09PSBmYWxzZSkge1xuICAgICAgICB2YWx1ZSA9IHRhYmxlWzBdW2luZGV4XVxuICAgICAgICBzcGFjaW5nID0gY2FsY3VsYXRlU3RyaW5nTGVuZ3RoKHN0cmluZ2lmeSh2YWx1ZSkpXG4gICAgICAgIHNwYWNpbmcgPSBzcGFjaW5nID4gbWluQ2VsbFNpemUgPyBzcGFjaW5nIDogbWluQ2VsbFNpemVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNwYWNpbmcgPSBzaXplc1tpbmRleF1cbiAgICAgIH1cblxuICAgICAgYWxpZ24gPSBhbGlnbm1lbnRbaW5kZXhdXG5cbiAgICAgIC8vIFdoZW4gYGFsaWduYCBpcyBsZWZ0LCBkb24ndCBhZGQgY29sb25zLlxuICAgICAgdmFsdWUgPSBhbGlnbiA9PT0gbG93ZXJjYXNlUiB8fCBhbGlnbiA9PT0gJycgPyBkYXNoIDogY29sb25cbiAgICAgIHZhbHVlICs9IHBhZChzcGFjaW5nIC0gMiwgZGFzaClcbiAgICAgIHZhbHVlICs9IGFsaWduICE9PSBsb3dlcmNhc2VMICYmIGFsaWduICE9PSAnJyA/IGNvbG9uIDogZGFzaFxuXG4gICAgICBydWxlW2luZGV4XSA9IHZhbHVlXG4gICAgfVxuXG4gICAgcm93cy5zcGxpY2UoMSwgMCwgcnVsZS5qb2luKGRlbGltaXRlcikpXG4gIH1cblxuICByZXR1cm4gc3RhcnQgKyByb3dzLmpvaW4oZW5kICsgbGluZUZlZWQgKyBzdGFydCkgKyBlbmRcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gJycgOiBTdHJpbmcodmFsdWUpXG59XG5cbi8vIEdldCB0aGUgbGVuZ3RoIG9mIGB2YWx1ZWAuXG5mdW5jdGlvbiBsZW5ndGhOb29wKHZhbHVlKSB7XG4gIHJldHVybiBTdHJpbmcodmFsdWUpLmxlbmd0aFxufVxuXG4vLyBHZXQgYSBzdHJpbmcgY29uc2lzdGluZyBvZiBgbGVuZ3RoYCBgY2hhcmFjdGVyYHMuXG5mdW5jdGlvbiBwYWQobGVuZ3RoLCBjaGFyYWN0ZXIpIHtcbiAgcmV0dXJuIG5ldyBBcnJheShsZW5ndGggKyAxKS5qb2luKGNoYXJhY3RlciB8fCBzcGFjZSlcbn1cblxuLy8gR2V0IHRoZSBwb3NpdGlvbiBvZiB0aGUgbGFzdCBkb3QgaW4gYHZhbHVlYC5cbmZ1bmN0aW9uIGRvdGluZGV4KHZhbHVlKSB7XG4gIHZhciBtYXRjaCA9IGxhc3REb3RSZS5leGVjKHZhbHVlKVxuXG4gIHJldHVybiBtYXRjaCA/IG1hdGNoLmluZGV4ICsgMSA6IHZhbHVlLmxlbmd0aFxufVxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJtYXJrZG93blRhYmxlIiwiZG90UmUiLCJsYXN0RG90UmUiLCJzcGFjZSIsImxpbmVGZWVkIiwiZGFzaCIsImRvdCIsImNvbG9uIiwibG93ZXJjYXNlQyIsImxvd2VyY2FzZUwiLCJsb3dlcmNhc2VSIiwidmVydGljYWxCYXIiLCJtaW5DZWxsU2l6ZSIsInRhYmxlIiwib3B0aW9ucyIsInNldHRpbmdzIiwiZGVsaW1pdGVyIiwic3RhcnQiLCJlbmQiLCJhbGlnbm1lbnQiLCJhbGlnbiIsImNhbGN1bGF0ZVN0cmluZ0xlbmd0aCIsInN0cmluZ0xlbmd0aCIsImxlbmd0aE5vb3AiLCJjZWxsQ291bnQiLCJyb3dJbmRleCIsInJvd0xlbmd0aCIsImxlbmd0aCIsInNpemVzIiwicnVsZSIsInJvd3MiLCJyb3ciLCJjZWxscyIsImluZGV4IiwicG9zaXRpb24iLCJzaXplIiwidmFsdWUiLCJzcGFjaW5nIiwiYmVmb3JlIiwiYWZ0ZXIiLCJjb25jYXQiLCJ1bmRlZmluZWQiLCJkb3RpbmRleCIsInBhZCIsInNwbGl0IiwiY2hhckF0IiwidG9Mb3dlckNhc2UiLCJzdHJpbmdpZnkiLCJ0ZXN0Iiwiam9pbiIsInNwbGljZSIsIlN0cmluZyIsImNoYXJhY3RlciIsIkFycmF5IiwibWF0Y2giLCJleGVjIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/markdown-table/index.js\n");

/***/ })

};
;